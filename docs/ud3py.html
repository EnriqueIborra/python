<!DOCTYPE html>
<html lang="ca-ES">  
  <!--  al ponerlo en catalan, fuerzo al navegador a poner el traductor-->
  <!-- es-ES  lenguaje - ubicacion    -->
<head>
  <meta charset="UTF-8">
  <link rel="alternate" hreflang="ca-ES">
  <link rel="icon" href="https://www.python.org/favicon.ico"> 
  <title> Introducci√≥ a la programaci√≥</title>
  <link rel="stylesheet" href="estilsunitatspy.css">
  <link rel="stylesheet" href="https://cdn.hugeicons.com/font/hgi-stroke-rounded.css" />
</head>
<body>

  <header>
    <a href="index.html"><img src="imgs/phyton2-rbg.png" alt="python"></a>
    <h1>Unitat Did√†ctica 3: Tipus Avan√ßats</h1>
    <h1> </h1>
  </header>

<nav>
  <h3>√çndex</h3>
  <a href="#estruc">Estructures avan√ßades</a>
  <a href="#llistes">Llistes</a>
  <a href="#tuples">Tuples</a>
  <a href="#conjunts">Conjunts</a>
  <a href="#diccionaris">Diccionaris</a>
  <a href="#gc">El Garbage Collector</a>
  <a href="#funcionsav">Funcions avan√ßades en Python</a>
  <a href="#arrays">Arrays</a>
  <a href="#dates">Dates</a>
  <a href="#exercicis">Exercicis</a>

   
</nav>

<main>

<section id="estruc">

      <h1>Estructures avan√ßades en Python</h1>
  
      <p>En Python, les dades es divideixen en mutables i immutables, depenent de si el seu contingut pot canviar despr√©s de la seua creaci√≥.</p>
  
      <p>Els objectes immutables no poden canviar el seu contingut despr√©s de ser creats. Qualsevol ‚Äúmodificaci√≥‚Äù realment crea un nou objecte en mem√≤ria.</p>
  
      <p><strong>En Python, els tipus de dades immutables:</strong></p>
      <ul>
          <li>Nombres (int, float, complex)</li>
          <li>Cadenes de text (str)</li>
          <li>Tuples (tuple)</li>
          <li>Conjunts immutables (frozenset)</li>
          <li>Booleans (bool)</li>
      </ul>
      <hr>
      <p>Els objectes mutables poden canviar el seu contingut sense canviar la seua identitat en mem√≤ria.</p>
  
      <p><strong>En Python, els tipus de dades mutables:</strong></p>
      <ul>
          <li>Llistes (list)</li>
          <li>Diccionaris (dict)</li>
          <li>Conjunts (set)</li>
          <li>Objectes definits per l'usuari (classes)</li>
      </ul>
  
      <h2>Objectes immutables (int, str, bool...)</h2>
      <p>a = 3 &nbsp; &nbsp;# Es crea el literal 3 en mem√≤ria i s'assigna el seu ‚Äúidentificador‚Äù a la variable a</p>
      <p>b = 3 &nbsp; &nbsp;# Com que el literal 3 ja existeix, se li assigna el seu ‚Äúidentificador‚Äù a la variable b</p>
      <p>a = 5 &nbsp; &nbsp;# Es crea el literal 5 en mem√≤ria i s'assigna el seu ‚Äúidentificador‚Äù a la variable a</p>
      <img src="imgs/inmutables.png" alt="inmutables" width="60%">
      <p>Per ‚Äúidentificador‚Äù es fa refer√®ncia a un identificador d'objecte (no a una adre√ßa de mem√≤ria). Aquest identificador es pot obtindre amb la funci√≥ <code>id(var)</code>.</p>
       
      <h3>Prova:</h3>
      <pre>
  >>> a = 9
  >>> b = 10
  >>> id(a)
     11754152
  >>> id(b)
     11754184
  >>> b = a
  >>> id(b)
     11754152
      </pre>
  
      <p>En Python es produeix <strong>aliasing</strong>, √©s a dir, els objectes tenen individualitat, i m√∫ltiples noms poden referir-se al mateix objecte.</p>
      <hr>
      <h2>Objectes mutables (llistes, diccionaris, conjunts, definits per l'usuari...)</h2>
      <p>En Python, les variables s√≥n refer√®ncies a objectes en mem√≤ria, no contenidors de dades directament. Quan fas una assignaci√≥ com:</p>
      <p><code>a = [1, 2, 3]</code> &nbsp; &nbsp;# a √©s una llista, per tant mutable</p>
      <p><code>b = a</code></p>
      <p>Tant <code>a</code> com <code>b</code> apunten al mateix objecte (una llista en aquest cas). No es crea una c√≤pia de la llista; simplement, ambdues variables fan refer√®ncia al mateix objecte. Si modifiques la llista a trav√©s de <code>b</code>:</p>
      <p><code>b.append(4)</code> &nbsp; &nbsp;# aix√≤ afegeix un element al final de la llista</p>
      <p>La llista a la qual <code>a</code> apunta tamb√© es veu modificada, ja que <code>a</code> i <code>b</code> fan refer√®ncia al mateix objecte en mem√≤ria.</p>
  
      <h3>Refer√®ncies i aliasing</h3>
      <img src="imgs/mutables.png" alt="mutables" width="60%">
  
      <p>La difer√®ncia amb els objectes immutables √©s que quan modifiquem un objecte mutable, no es crea un de nou (si no existeix), com passa amb els immutables. Es modifica l‚Äôobjecte i es mantenen les refer√®ncies.</p>
  
    
      <p>Una altra difer√®ncia amb els immutables √©s que quan assignem una llista a una variable, ES CREA una nova llista (encara que ja n‚Äôexistisca una amb els mateixos elements).</p>
      <img src="imgs/mutables2.png" alt="mutables2" width="30%" class="imatge-dreta">
      <p><code>a = [1, 2, 3]</code></p>
      <p><code>b = [1, 2, 3]</code></p>
      
      <p>Aix√≤ no pot passar amb els objectes immutables. En el cas de dos objectes immutables iguals, s‚Äôapunta al mateix.</p>
  
          <h2>Objectes mutables (llistes, diccionaris, conjunts, definits per l'usuari...)</h2>
      
          <p>En Python, les variables s√≥n refer√®ncies a objectes en mem√≤ria, no contenidors de dades directament. Quan fas una assignaci√≥ com:</p>
      
          <pre>a = [1, 2, 3]     # a √©s una llista, per tant mutable  
      b = a</pre>
      
          <p>Tant <code>a</code> com <code>b</code> apunten al mateix objecte (una llista en aquest cas). No es crea una c√≤pia de la llista; simplement, ambdues variables fan refer√®ncia al mateix objecte. Si modifiques la llista a trav√©s de <code>b</code>:</p>
      
          <pre>b.append(4)   # aix√≤ afegeix un element al final de la llista</pre>
      
          <p>La llista a la qual <code>a</code> apunta tamb√© es veu modificada, ja que <code>a</code> i <code>b</code> fan refer√®ncia al mateix objecte en mem√≤ria.</p>
      
          <h3>Refer√®ncies i aliasing</h3>
      
          <p>La difer√®ncia amb els objectes immutables √©s que quan modifiquem un objecte mutable, no es crea un de nou (si no existeix), com passa amb els immutables. Es modifica l‚Äôobjecte i es mantenen les refer√®ncies.</p>
      
          <p>Una altra difer√®ncia amb els immutables √©s que quan assignem una llista a una variable, ES CREA una nova llista (encara que ja n‚Äôexistisca una amb els mateixos elements).</p>
      
          <pre>a = [1, 2, 3]
      b = [1, 2, 3]</pre>
      
          <p>Aix√≤ no pot passar amb els objectes immutables. En el cas de dos objectes immutables iguals, s‚Äôapunta al mateix.</p>
   

</section>

<section id="llistes">
      <h2>Llistes []</h2>
      <img src="imgs/llista.png" alt="llista" width="40%" class="imatge-dreta">
      <p>Les llistes s√≥n estructures de dades que poden emmagatzemar diversos elements.</p>
      <ul>
          <li>S√≥n ordenades. Suporten indexaci√≥ i slicing.</li>
          <li>S√≥n Mutables: Es poden modificar despr√©s de ser creades.</li>
          <li>Es poden afegir o eliminar elements amb m√®todes com <code>append()</code>, <code>remove()</code>, <code>pop()</code>, etc.</li>
          <li>Els elements poden ser mutables o immutables.</li>
          <li>Es poden niar.</li>
      </ul>
      <br><p>Dir que les llistes de Python s√≥n ordenades significa que mantenen l'ordre d'inserci√≥ dels seus elements.
        (Una altra cosa √©s dir que els elements estan ordenats).
      </p>

      <ol> <strong>Aix√≤ implica</strong>
        <li>Ordre d'Inserci√≥ Fixe: L'ordre en qu√® afegiu els elements a una llista √©s l'ordre en qu√® es guarden. 
            Aquest ordre √©s estable i previsible i nom√©s canviar√† si feu una operaci√≥ espec√≠fica per reordenar-la (com ara .sort() o .reverse()).</li>
        <li>Indexaci√≥: Podeu accedir a qualsevol element de la llista utilitzant el seu √≠ndex num√®ric (posici√≥), 
            comen√ßant per 0. Aix√≤ √©s possible precisament perqu√® la posici√≥ de cada element no varia.</li>
        <li>Iteraci√≥ Previsible: Quan recorreu la llista (amb un bucle for, per exemple), els elements 
            sempre eixiran en la seq√º√®ncia exacta en qu√® varen ser introdu√Øts</li>
      </ol>
  <h4>Vegem com manipular llistes amb exemples..</h4>
      <pre>  llista=[]     # declara llista buida
  fruites = ["poma", "pl√†tan", "cirera"]   # declara llista amb 3 elements
  llista = list("1234")                    # fa una llista a partir dels caracters d'un string
  llista = [1, "Hola", 3.67, [1, 2, 3]]    # pot barrejar tipus diferents
  print(fruites[0])                        # Impremeix el primer element
  fruites[0] = "pera"
  del fruites[1]                           # Esborra el segon element de la llista
  fruites.append("taronja")                # afegeix un element 
  print(fruites)    print(*fruites)    print(*fruites, sep=' -> ')
  len(fruites)                             # Torna "quants" elements t√© la llista
  max(fruites)   min(fruites)
  sum(mevallista)  
  mevallista = []
  mevallista[0] = 24   mevallista[1] = 46
  mevallista[-1] = 33  mevallista[-2] = 57
  nouafruita = fruites[2:4]
  nouafruita2 = fruites[:4]   nouafruita3 = fruites[2:]
  llista2 = [1, 4, 7, "pl√†tan"]
  mevallista.insert(1, 15)       # Inserta en la posici√≥ 1, el element 15
  mevallista.extend([7, 8, 9])   # Afegix els elements de la lista , u per u
  mevallista.remove(15)          # Esborra l'element 15, si hi ha m√©s d'u, sols esborra el primer.
  mevallista.clear()             
  ultim = mevallista.pop()
  altre = mevallista.pop(2)      # posici√≥ 2  ( la primera pos es la 0, l'ultima la -1)
  print(10 in mevallista)        # True o False
  index = mevallista.index("pl√†tan")     # posici√≥ del primer element 'pl√†tan' ( si hi ha m√©s d'u)
  
  mevallista.sort()                      # ordena els elements de la llista , modificant-la !!
      # Si els elements d'una llista no son del mateix tipus, no es podran ordenar
      # I si s'intenta, donar√† un Error =>  TypeError

  llista_ordenada = sorted(mevallista)   # Torna una llista nova ordenada, pero no modifica la principal
  mevallista.reverse()                   #  modifica...
  print(mevallista.count("pera"))    
  copia_llista = mevallista.copy()
  copia_llista = mevallista[:]
  llista_niada = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]
  llista3 = llista1 + llista2
  llista_repetida = llista1 * 3
  x, y, z = llista
  llista_sense_duplicats = list(set(mevallista))
  resultat = all(x % 2 == 0 for x in mevallista)
  resultat = any(x % 2 == 0 for x in mevallista)       </pre>
     <h4>Com recorrer una llista</h4>
      <pre>
for e in llista: print(e)    # e ser√† un element de la llista en cada iteraci√≥
                             # e pot ser de qualsevol tipus, incl√≤s llista (llista niada)
for i in range(len(llista)):
        print(llista(i))     #  i ser√† un numero de 0 a len(llista)  , llista(i) ser√† l'element
for index, l in enumerate(llista): print(index, l)   

#  dins dels bucles ens pot ser molt √∫til saber el tipus de cada element
type(llista1) is list
isinstance(llista1, list)
      </pre>
      <h4>Algunes conversions √∫tils</h4>
      <pre># De string fer una llista
string1='Python'
l=list(string1)
print(l)     # l cont√© una llista  ['P','y','t','h','o','n']
 
# Per tornar a convertir una llista a string s'utilitzar√†  <strong>join</strong>
# <strong>str</strong> no fa la conversi√≥ molt b√©...
string2=''.join(a)
print(string2)          #  Python

# O es pot "unir" amb qualsevol lletra
string3=','.join(a)
print(string3)          #  P,y,t,h,o,n     </pre>
  
      <h3>Python List comprehension o Comprensi√≥ de llistes en Python</h3>
      <p>La comprensi√≥ de llistes en Python √©s una manera concisa i eficient de crear llistes a partir d'iterables com llistes, tuples, rangs, etc.</p>
      <p><strong>Sintaxi b√†sica:</strong></p>
      <pre>
  nova_llista = [expressio for element in iterable if condici√≥]
      ‚Ä¢ expressio: operaci√≥ o transformaci√≥ aplicada a cada element
      ‚Ä¢ element: variable que pren els valors de l'iterable
      ‚Ä¢ iterable: objecte iterable (llista, tupla, rang, etc.)
      ‚Ä¢ if condici√≥ (opcional): filtra els elements
      </pre>
  
      <h4>Exemples de comprensi√≥ de llistes</h4>
      <ol>
          <li>
              <strong>Crear una llista de quadrats:</strong>
              <pre>
  quadrats = [x**2 for x in range(10)]
  print(quadrats)  
  # Resultat: [0, 1, 4, 9, 16, 25, 36, 49, 64, 81]</pre>
          </li>
          <li>
              <strong>Filtrar nombres parells:</strong>
              <pre>
  parells = [x for x in range(10) if x % 2 == 0]
  print(parells)  
  # Resultat: [0, 2, 4, 6, 8]</pre>
          </li>
          <li>
              <strong>Convertir paraules a maj√∫scules:</strong>
              <pre>
  paraules = ["hola", "m√≥n", "python"]
  majuscules = [paraula.upper() for paraula in paraules]
  print(majuscules)  
  # Resultat: ['HOLA', 'M√ìN', 'PYTHON']</pre>
          </li>
      </ol>
       
</section>

<section id="tuples">

      <h2>Tuples ()</h2>
      <img src="imgs/tupla.png" alt="tupla" width="40%" class="imatge-dreta">
      <p>Les tuples s√≥n com les llistes per√≤, una vegada declarades, <strong>no es poden modificar</strong> (s√≥n immutables).</p>
      <ul>
          <li>S√≥n ordenades. Suporten indexaci√≥ i slicing.</li>
          <li>S√≥n Immutables: No es poden modificar despr√©s de ser creades.</li>
          <li>No Es poden afegir o eliminar elements.</li>
          <li>Els elements poden ser mutables o immutables.(per exemple, una llista dins d‚Äôuna tupla <b>S√≠</b> que pot canviar).</li>
          <li>Es poden niar.(una tupla pot contenir altres tuples).</li>
      </ul>  


      <pre>
  mesosAny = ("Gen", "Feb", "Mar", "Abr", "Mai", "Jun", "Jul", "Ago", "Set", "Oct", "Nov", "Des")
  mesosAny[1]           # acc√©s al segon element
  mesosAny[-1]          # acc√©s a l'√∫ltim element
  mesosAny[:2]          # slicing
  mesosAny[0] = 8       # ERROR, no podem modificar
  tupla1 = ()           # tupla buida
  tupla2 = (6,)         # tupla d'un sol element, cal posar la coma!
  tupla1 + tupla2       # concatenar tuples
  tupla2 * 3            # repetir la tupla 3 vegades
  "Mai" in mesosAny     # retorna True
  len(tupla2)           # nombre d'elements
  max, min, sum         # si els valors s√≥n compatibles
  tupla1.count(23)      # comptar ocurr√®ncies
  tupla1.index(23)      # posici√≥ d'un valor
  tupla1.index(23, 3)   # a partir de la posici√≥ 3
  tupla = tuple(llista) # convertir una llista en tupla
  sorted(tupla)         # retorna una llista ordenada
  nova_llista = list(tupla)  # convertir una tupla en llista
  tupla = (1, 2, 3)
  a, b, c = tupla       # desempaquetat
  tupla = (1, 2, 3, 4, 5)
  TUPLA2 = 1, 2, 3, 4    # altra forma de definir
  a, *b, c = tupla       # a=1, b=[2,3,4], c=5
  v = 1                 # NO √©s una tupla
  x = (2)               # NO √©s una tupla
  y = (1,)              # S√ç √©s una tupla
  tupla = 1, 2, ('a', 'b'), 3   # tupla amb elements niats
  for t in tupla: print(t)     # recorregut de la tupla
  type(tupla2) is tuple        # comprova si √©s una tupla
      </pre>
      <pre># Una tupla no es pot re-ordenar, perqu√® √©s inmutable, 
# per√≤ es pot crear una altra tupla ordenada
t=(4,7,1,9,2,2)
t2=tuple(sorted(t))    # sorted(t) crea una llista ordenada a partir de t, 
                       # i tuple converteix una llista en una tupla   </pre>
  
      <h3>Quan usar tuples en lloc de llistes?</h3>
      <ul>
          <li>Quan les dades no han de canviar (exemple: coordenades, dies de la setmana).</li>
          <li>Quan es busca m√©s efici√®ncia (les tuples consumeixen menys mem√≤ria i s√≥n m√©s r√†pides).</li>
          <li>Quan es necessiten dades <strong>hashables</strong> (les tuples es poden usar com a claus en diccionaris, les llistes no).</li>
      </ul>
  
      <h3>Tuple Comprehension?</h3>
      <p>En Python <strong>no existeix</strong> la "tuple comprehension" com a tal.</p>
      <p>Si usem par√®ntesis (<code>()</code>) per intentar fer una comprensi√≥, Python ho interpreta com un <strong>generator expression</strong>:</p>
      <pre>
  tupla = (x**2 for x in range(5))
  print(tupla)
  # Resultat: &lt;generator object at 0x...&gt;
      </pre>
      <p>A√ß√≤ <strong>no</strong> crea una tupla, sin√≥ un objecte generador. Per convertir-lo en tupla:</p>
      <pre>
  tupla = tuple(x**2 for x in range(5))
  print(tupla)
      </pre>
  
      <h4>Avantatges d‚Äôun generador:</h4>
      <ol>
          <li><strong>Efici√®ncia de mem√≤ria</strong>: no carrega tots els elements a mem√≤ria.</li>
          <li><strong>Rendiment</strong>: √∫til per a grans volums de dades.</li>
          <li><strong>Simplicitat</strong>: codi m√©s net que una funci√≥ generadora.</li>
      </ol>


</section>

<section id="conjunts">

      <h2>Conjunts -sets-  {}</h2>
      <img src="imgs/conjunt.png" alt="conjunt" width="40%" class="imatge-dreta">
      <h3>Caracter√≠stiques principals</h3>
      <ol>
          <li><strong>Elements √∫nics</strong>: Un conjunt no pot contindre duplicats.</li>
          <li><strong>No ordenats</strong>: Els elements no tenen un ordre espec√≠fic.</li>
          <li><strong>Mutables</strong>: Es poden afegir o eliminar elements.</li>
          <li><strong>Els elements han de ser immutables</strong>: podem afegir o llevar, per√≤ no modificar un element concret.</li>
      </ol>
      <p><strong>Ordenats o No ordenats</strong>: en Python els conjunts (sets) no s√≥n ordenats.
Aix√≤ vol dir que els elements d'un conjunt no tenen una posici√≥ espec√≠fica o un ordre fixe. 
Quan s'imprimeix un conjunt o s'itera sobre ell, l'ordre dels elements pot ser diferent 
del que es va utilitzar per crear-lo i, de fet, pot canviar entre diferents execucions 
del programa o amb el temps.</p>

     <strong>üî¢ Qu√® passa amb els Nombres? </strong>
     <p>Quan Python mostra un conjunt de nombres, pot semblar que est√† ordenat de vegades,
         per√≤ aix√≤ √©s una coincid√®ncia a causa de com es calcula el hash i com s'organitzen 
         els nombres a la mem√≤ria, no √©s una propietat garantida del tipus de dades set</p>
  
      <h3>Exemples d‚Äô√∫s</h3>
      <pre>
  conjunt_buit={}        # No es construeix aix√≠ un conjunt
  conjunt_buit = set()   #Aix√≠ SI
  conjunt = {1, 2, 2, 3}
  print(conjunt)               # Eixida: {1, 2, 3}
  conjunt = set([1, 2, 3, 3])  # convertir una llista en conjunt
  conjunt = set( (1, 2, 3, 3) ) # convertir una tupla en conjunt
  conjunt.add(3)               # afegir un element ( el nombre 3)
  conjunt.remove(2)            # elimina el nombre 2, dona error si no existeix
  conjunt.discard(4)           # elimina el nombre 4, no dona error si no existeix
  conjunt.pop()                # elimina i retorna un element aleatori. Si c es buit dona Error
  conjunt.clear()              # buida el conjunt
  
  len(conjunt)                 # n√∫mero d‚Äôelements
  print(5 in conjunt)          # pertinen√ßa: True si 5 est√† en el conjunt
  type(conjunt) is set         # comprova si √©s un conjunt
  
  a = frozenset([1, 2, 3])     # conjunt immutable
  conjunt = {1, 2.5, "hola", (1, 2), frozenset([3, 4])}
  
  for element in conjunt:
      print(element)
      </pre>
  
      <h3>Operacions entre conjunts</h3>
      <pre>
  print(a.issubset(b))         # a est√† contingut en b
  print(a.issuperset(b))       # a cont√© tots els elements de b
  print(a.isdisjoint(b))       # a i b no tenen cap element en com√∫
 
  <img src="imgs/conjunts_ops.png" alt="opseracions conjunts" width="40%" class="imatge-dreta">
  # Uni√≥
  print(s1 | s2)       
  print(s1.union(s2))
  # No es modifica el conjunt original
  
  # Intersecci√≥
  print(s1 & s2)
  print(s1.intersection(s2))
  
  # Difer√®ncia
  print(s1 - s2)
  print(s1.difference(s2))
  
  # Difer√®ncia sim√®trica
  print(s1 ^ s2)
  print(s1.symmetric_difference(s2))
      </pre>
  
      <h4>M√®todes destructius (modifiquen el conjunt original):</h4>
      <pre>
  conjunt.update(iterable)                 # Afegix elements de l'iterable al conjunt
                            # Equival a  conjunt |= set(iterable)
  conjunt.intersection_update(iterable)
  conjunt.difference_update(iterable)
  conjunt.symmetric_difference_update(iterable)
      </pre>
  
      <h3>Set Comprehension</h3>
      <p>√âs una forma compacta de crear conjunts.</p>
      <pre>
  nou_conjunt = {expressio for element in iterable if condici√≥}
  # Exemple:
  parells = {x for x in range(10) if x % 2 == 0}
      </pre>
  
</section>

<section id="diccionaris">
      <h2>Diccionaris { , }</h2>
      <img src="imgs/diccionaris.png" alt="diccionaris" width="55%" class="imatge-dreta">
      <p>Els diccionaris emmagatzemen parells clau-valor.</p>
  
      <h3>Caracter√≠stiques principals</h3>
      <ol>
          <li>Mutables</li>
          <li>No permeten claus duplicades. Si s‚Äôafegeix una clau repetida, el seu valor ser√† sobreescrit.</li>
          <li>Les claus han de ser <strong>immutables</strong>. Poden ser <code>str</code>, <code>int</code>, <code>tuple</code>, per√≤ no <code>list</code> o <code>dict</code>.</li>
          <li>Mantenen l‚Äôordre d‚Äôinserci√≥ (des de Python 3.7).</li>
      </ol>
  
      <h3>Exemples d‚Äô√∫s</h3>
      <pre>
  dic = {}  # Diccionari buit
  persona = {"nom": "Carlos", "edat": 30, "ciutat": "Madrid"}
  print(persona["nom"])  # Accedeix al valor d‚Äôuna clau. Imprimeix 'Carlos'
  
  dic["nova_clau"] = "nou_valor"      # Afegir una nova clau
  dic["clau1"] = "valor_actualitzat"  # Modificar el valor d'una clau existent
  valor = dic["clau1"]  # Accedir a un valor (error si no existeix)
  valor = dic.get("clau1", "per defecte")  # Evita errors si no existeix
  
  del dic["clau1"]  # Eliminar una clau
  valor = dic.pop("clau2", None)  # Elimina i retorna el valor, o None
  
  dic.clear()  # Buida el diccionari
  
  if "clau1" in dic:
      print("Clau trobada")
  
  # Iteracions
  for clau in dic:
      print(clau)
  
  for valor in dic.values():
      print(valor)
  
  for clau, valor in dic.items():
      print(clau, valor)
  
  tamany = len(dic)  # Nombre d‚Äôelements
  nou_dic = dic.copy()  # C√≤pia superficial
  dic.update({"clau3": "valor3", "clau4": "valor4"})  # Afegir/modificar diverses claus
  
  claus = dic.keys()     # objecte dict_keys
  valors = dic.values()  # objecte dict_values
  items = dic.items()    # objecte dict_items
  
  type(dic) is dict  # Comprova si √©s un diccionari

  dict.update(dict2)   # Fundeix dos diccionaris. Modifica dict. Retorna None
  d.update(y=2, z=3)  # Passant m√©s d'un parell, com arguments
  d.update([("y", 2), ("z", 3)])  # Passant tuples, com arguments
  
  dic1 | dic2   # (Python 3.9+) Fundeix dos diccionaris. Prioritza dic2. Retorna diccionari. 
                # No modifica ni dict1 ni dict2

  dic1 |= dic2  # Fusiona i actualitza dic1. Equival a dic1 = dic1 | dic2
      </pre>
  
      <h3>Claus i valors mutables</h3>
      <p>Les claus han de ser immutables, per√≤ els valors poden ser de qualsevol tipus, fins i tot llistes o altres diccionaris.</p>
      <pre>
  dic = {(1, 2): "punt", (3, 4): "altre punt"}
  print(dic[(1, 2)])  # "punt"
      </pre>
  
      <h3>Comprensi√≥ de Diccionaris (Dictionary Comprehension)</h3>
      <p>Permet construir diccionaris de manera compacta a partir d‚Äôun iterable:</p>
      <pre>
  numeros = [1, 2, 3, 4]
  quadrats = {n: n**2 for n in numeros}
  print(quadrats)  # {1: 1, 2: 4, 3: 9, 4: 16}
      </pre>

      <h2>Funcions <code>lambda</code> (funcions an√≤nimes)</h2>

      <p>Una expressi√≥ <code>lambda</code> en Python permet crear funcions petites i an√≤nimes (sense nom). S√≥n √∫tils per definir comportaments r√†pids o temporals, especialment dins d‚Äôestructures com diccionaris, funcions d‚Äôordre superior (<code>map</code>, <code>filter</code>, <code>sorted</code>, etc.) o comprensions.</p>
      
      <h3>Sintaxi</h3>
      <pre>
      lambda arguments: expressi√≥
      </pre>
      <p>Exemple b√†sic:</p>
      <pre>
      f = lambda x: x * 2
      print(f(4))   # Imprimeix 8
      </pre>
      
      <h3>Exemple amb diccionari de funcions</h3>
      <pre>
      operacions = {
          "suma": lambda x, y: x + y,
          "resta": lambda x, y: x - y
      }
      print(operacions["suma"](10, 5))  # Imprimeix 15
      print(operacions["resta"](10, 5))  # Imprimeix 5
      </pre>
      
      <p>En este cas, <code>operacions</code> √©s un diccionari que guarda funcions lambda com a valors. Cada clau representa una operaci√≥ aritm√®tica, i pots executar la funci√≥ cridant-la amb els arguments corresponents.</p>

</section>

<section id="gc">
  <h2>El Garbage Collector (GC) de Python</h2>
  <p>   El <strong>Garbage Collector</strong> √©s el mecanisme encarregat d'<strong>administrar la mem√≤ria autom√†ticament</strong> en Python. Elimina els objectes que ja no s‚Äôutilitzen, alliberant espai i evitant fugues de mem√≤ria.
  </p>
  
  <h3>Exemple conceptual</h3>
  <pre>
    <img src="imgs/gc.png" alt="gc" width="65%" class="imatge-dreta">
  >>> b = 3
  >>> a = 5
  >>> a = b
  </pre>
  
  <p>   Quan <code>a = 5</code>, l‚Äôobjecte <code>5</code> t√© una refer√®ncia. Per√≤ despr√©s <code>a = b</code>, <code>a</code> passa a referenciar <code>3</code>. Com ning√∫ apunta ja a <code>5</code>, queda sense √∫s i el GC el pot eliminar.
  </p>
  <hr>
  <h3>Funcionament intern</h3>
  <ul>
    <li><strong>Conteig de refer√®ncies:</strong> cada objecte t√© un comptador que indica quantes refer√®ncies l‚Äôapunten. Si arriba a zero, es pot eliminar autom√†ticament.</li>
    <li><strong>Recol¬∑lecci√≥ de brossa generacional:</strong> els objectes s‚Äôorganitzen en <em>generacions</em> (0, 1 i 2). Els nous comencen en la generaci√≥ 0, i si ‚Äúsobreviuen‚Äù diverses neteges, passen a generacions superiors.</li>
  </ul>
  
  <p>   Python fa neteges m√©s freq√ºents en la generaci√≥ 0 que en les superiors, perqu√® √©s m√©s probable que els objectes nous siguen de curta duraci√≥.
  </p>
  
  <h3>Control manual amb el m√≤dul <code>gc</code></h3>
  <p>Encara que el GC funciona autom√†ticament, es pot controlar manualment amb el m√≤dul <code>gc</code>:</p>
  <pre>
  import gc
  
  gc.collect()      # For√ßa una execuci√≥ del garbage collector
  gc.get_stats()    # Mostra estad√≠stiques sobre el GC
  </pre>

</section>

<section id="funcionsav">
  <h2>Funcions Avan√ßades en Python</h2>

  <h3>√ös de <code>*args</code> i <code>**kwargs</code></h3>
  <p>
  <strong>*args</strong> permet passar un nombre variable d‚Äôarguments posicionals a una funci√≥. S‚Äôemmagatzemen com una tupla.
  </p>
  <pre>
  def sumar(*args):
      return sum(args)
  
  print(sumar(1, 2, 3, 4))  # Output: 10
  </pre>
  
  <p>
  <strong>**kwargs</strong> permet passar arguments amb clau i valor (com un diccionari) sense definir-los pr√®viament.
  </p>
  <pre>
  def mostrar_info(**kwargs):
      for clau, valor in kwargs.items():
          print(f"{clau}: {valor}")
  
  mostrar_info(nom="Anna", edat=30, ciutat="Val√®ncia")
  </pre>
  
  <p><strong>Difer√®ncia:</strong></p>
  <ul>
    <li><code>*args</code>: tupla d‚Äôarguments posicionals.</li>
    <li><code>**kwargs</code>: diccionari d‚Äôarguments amb nom.</li>
  </ul>
  
  <p>Exemple combinat:</p>
  <pre>
  def exemple(*args, **kwargs):
      print("Args:", args)
      print("Kwargs:", kwargs)
  
  exemple(1, 2, 3, nom="Joan", edat=25)
  </pre>
  
  <h3>Funcions Lambda</h3>
  <p>
  Les funcions <strong>lambda</strong> s√≥n funcions an√≤nimes d‚Äôuna sola l√≠nia, √∫tils per a operacions curtes.
  </p>
  <pre>
  suma = lambda x, y: x + y
  print(suma(3, 5))  # 8
  
  cuadrat = lambda x: x ** 2
  print(cuadrat(4))  # 16
  
  es_par = lambda x: x % 2 == 0
  print(es_par(10))  # True
  </pre>
  
  <h4>Exemples amb funcions d‚Äôordre superior</h4>
  <pre>
  # map
  numeros = [1, 2, 3, 4]
  dobles = list(map(lambda x: x * 2, numeros))
  
  # filter
  pares = list(filter(lambda x: x % 2 == 0, numeros))
  
  # sorted amb clau
  paraules = ["poma", "pl√†tan", "kiwi"]
  ordenades = sorted(paraules, key=lambda x: len(x))
  </pre>
  
  <h3>Decoradors en Python</h3>
  <p>
  Un <strong>decorador</strong> √©s una funci√≥ que rep una altra funci√≥, l‚Äôamplia amb funcionalitat addicional, i retorna una nova funci√≥.
  </p>
  <pre>
  def mi_decorador(func):
      def nova_funcio():
          print("Abans de cridar la funci√≥")
          func()
          print("Despr√©s de cridar la funci√≥")
      return nova_funcio
  
  @mi_decorador
  def salutacio():
      print("Hola, m√≥n!")
  
  salutacio()
  </pre>
  
  <h4>Decoradors amb par√†metres</h4>
  <pre>
  def decorador_amb_args(func):
      def embolcall(*args, **kwargs):
          print(f"Cridant {func.__name__} amb {args} {kwargs}")
          return func(*args, **kwargs)
      return embolcall
  
  @decorador_amb_args
  def suma(a, b):
      return a + b
  </pre>
  
  <h4>Decorador amb par√†metres personalitzats</h4>
  <pre>
  def repetidor(n):
      def decorador(func):
          def embolcall(*args, **kwargs):
              for _ in range(n):
                  func(*args, **kwargs)
          return embolcall
      return decorador
  
  @repetidor(3)
  def hola():
      print("Hola!")
  
  hola()
  </pre>
  
  <h4>Decoradors predefinits</h4>
  <ul>
    <li><code>@staticmethod</code>: m√®tode est√†tic d‚Äôuna classe.</li>
    <li><code>@classmethod</code>: accedeix a la classe com a primer argument.</li>
    <li><code>@property</code>: converteix un m√®tode en propietat.</li>
  </ul>
  
  <pre>
  class Persona:
      def __init__(self, nom):
          self._nom = nom
  
      @property
      def nom(self):
          return self._nom
  
  p = Persona("Carles")
  print(p.nom)  # Sense par√®ntesis
  </pre>
  <hr>
  <h1>Generadors</h1>
    
  <p>Els <strong>generadors</strong> s√≥n una manera m√©s senzilla i eficient de crear iterables en Python. S'utilitzen funcions amb la paraula clau <code>yield</code> en lloc de <code>return</code>.</p>

  <p>Quan una funci√≥ cont√© <code>yield</code>, es converteix en un generador i pot conservar l'estat entre iteracions.</p>

  <h2>Exemple de generador:</h2>

  <pre><code>def comptador(inici, fi):
  while inici <= fi:
      yield inici
      inici += 1

for numero in comptador(1, 5):
  print(numero)
  </code></pre>

  <p>Este codi t√© el mateix comportament que la classe <code>Comptador</code> de l'exemple anterior, per√≤ √©s molt m√©s curt i f√†cil de llegir.</p>

  <h3>Avantatges dels generadors:</h3>
  <ul>
      <li>Menys codi i m√©s llegibilitat.</li>
      <li>No cal gestionar <code>__iter__</code> ni <code>__next__</code>.</li>
      <li>Estalvi de mem√≤ria, ja que els valors es generen sobre la marxa (lazy evaluation).</li>
  </ul>
 
</section>

<section id="arrays">

    <h1>Treballar amb Arrays en Python</h1>
    <p><b>Qu√® √©s un array:</b> Tamb√© se sol dir <code>vector</code> i √©s un tipus de dades estructurades, relacionat i homog√®ni, 
    es a dir, totes les dades del vector seran del mateix tipus</p>
    <img src="imgs/vector2.png" alt="vector" width="45%">
    <img src="imgs/matriz1.png" alt="matriu" class="imatge-dreta" width="30%">
    <p>Si els elemnts d'un vector, son vectors, estem parlant d'un vector bidimensional, o <code>matriu</code></p>
    
    <p>De igual manera es pot definir un cub, com a un vector de 3 dimensions, o un tesseracte o hipercub com un vector de 4 dimensions   </p>


    <p>En Python, es poden gestionar arrays mitjan√ßant <strong>llistes</strong> o utilitzant el m√≤dul <strong>NumPy</strong>. Aquesta √©s una biblioteca externa que proporciona funcionalitats espec√≠fiques per a computaci√≥ num√®rica.</p>

    <h2>Qu√® √©s NumPy?</h2> 
    <img src="imgs/numpy.png" alt="numpy" class="imatge-dreta" width="40%">
    <p><strong>NumPy</strong> (Numerical Python) √©s una de les biblioteques m√©s fonamentals i populars de Python per treballar amb computaci√≥ cient√≠fica i manipulaci√≥ de dades num√®riques.</p>
    <p>√âs √†mpliament utilitzada en √†rees com:</p>
    <ul>
        <li>An√†lisi de dades</li>
        <li>Intel¬∑lig√®ncia artificial</li>
        <li>Aprenentatge autom√†tic (<em>machine learning</em>)</li>
        <li>Processament d‚Äôimatges</li>
        <li>I molt m√©s</li>
    </ul>

    <h3>NumPy proporciona:</h3>
    <ol>
        <li><strong>Arrays multidimensionals</strong> per treballar amb dades de manera m√©s eficient que amb llistes de Python.</li>
        <li><strong>Funcions matem√†tiques optimitzades</strong> per fer operacions r√†pides i vectoritzades.</li>
        <li><strong>Eines per manipulaci√≥ de dades</strong>, √†lgebra lineal, transformades de Fourier, generaci√≥ de nombres aleatoris, etc.</li>
    </ol>

    <h2>Instal¬∑laci√≥</h2>
    <p>Si no tens instal¬∑lat NumPy, pots fer-ho amb la seg√ºent comanda:</p>
    <pre><code>$ pip3 install numpy</code></pre>

    <h2>Caracter√≠stiques principals de NumPy</h2>

    <h3>Arrays</h3>
    <p>El tipus de dades principal de NumPy √©s l'<code>ndarray</code> (array N-dimensional). Aquests s√≥n m√©s r√†pids i ocupen menys mem√≤ria que les llistes de Python.</p>

    <h3>Exemple b√†sic:</h3>
    <pre><code>import numpy as np

# Crear un array unidimensional
arreglo = np.array([1, 2, 3, 4])
print("Array:", arreglo)
print(arreglo[2])    # Un element
arreglo[2]=8         # Modificar un element

# Crear un array bidimensional (matriu)
matriu = np.array([[1, 2, 3], [4, 5, 6]])   # Dos files , tres columnes. files 0,1  columnes 0,1,2
print("Matriu:\n", matriu)
print("Element 1,2: ", matriu[1,2]) # ==> 6
matriu[1,2]=99                      # Canviar un element 
print("Matriu:\n", matriu)</code></pre>

    <p><strong>Explicaci√≥ dels exemples:</strong></p>
    <ul>
        <li><code>np.array([...])</code>: crea un array de NumPy a partir d'una llista de Python.</li>
        <li>Els arrays poden ser d'una sola dimensi√≥ (com una llista) o multidimensionals (com una matriu o tensor).</li>
        <li>Les operacions amb arrays s√≥n molt m√©s eficients que amb llistes, especialment en c√†lculs matem√†tics o estad√≠stics.</li>
    </ul>
    <hr>

    <h1>Vectoritzaci√≥ amb NumPy</h1>

    <p>NumPy permet realitzar operacions matem√†tiques sobre tots els elements d‚Äôun array d‚Äôuna sola vegada, sense necessitat d‚Äôutilitzar bucles (<em>loops</em>).</p>

    <h3>Exemple:</h3>
    <pre><code># Operacions matem√†tiques amb arrays
a = np.array([1, 2, 3])
b = np.array([4, 5, 6])
print("Suma:", a + b)  # [5 7 9]
print("Producte escalar:", a * 2)  # [2 4 6]</code></pre>

    <h2>Estalvi de mem√≤ria</h2>
    <p>NumPy emmagatzema les dades en un tipus homogeni (tots els elements s√≥n del mateix tipus), la qual cosa fa que siga m√©s eficient en √∫s de mem√≤ria que les llistes tradicionals de Python.</p>

    <h3>Exemple:</h3>
    <pre><code>import sys

llista = range(1000)
print("Mida de la llista:", sys.getsizeof(1) * len(llista))

arrel = np.arange(1000)
print("Mida de l'array NumPy:", arrel.nbytes)</code></pre>

    <h2>Funcions √∫tils</h2>
    <p>NumPy inclou moltes funcions predefinides per a c√†lculs matem√†tics:</p>
    <ul>
        <li><strong>Aritm√®tiques:</strong> <code>np.sum</code>, <code>np.mean</code>, <code>np.median</code>, <code>np.std</code>, <code>np.var</code></li>
        <li><strong>Operacions l√≤giques:</strong> <code>np.all</code>, <code>np.any</code></li>
        <li><strong>Generaci√≥ de nombres aleatoris:</strong> <code>np.random.rand</code>, <code>np.random.randint</code></li>
        <li><strong>√Älgebra lineal:</strong> <code>np.dot</code>, <code>np.linalg.inv</code>, <code>np.linalg.eig</code></li>
    </ul>

    <h3>Exemple de c√†lculs estad√≠stics:</h3>
    <pre><code># Estad√≠stiques b√†siques
dades = np.array([10, 20, 30, 40])
print("Mitjana:", np.mean(dades))
print("Desviaci√≥ est√†ndard:", np.std(dades))</code></pre>

    <h2>Creaci√≥ d'arrays especialitzats</h2>
    <p>NumPy facilita la creaci√≥ d'arrays amb valors espec√≠fics de forma r√†pida i senzilla.</p>

    <h3>Exemples:</h3>
    <pre><code># Array de zeros
zeros = np.zeros((2, 3))  # 2 files, 3 columnes
print("Zeros:\n", zeros)

# Array d'unos
unos = np.ones((3, 2))
print("Unos:\n", unos)

# Array amb valors en un rang
rang = np.arange(0, 10, 2)  # Inici, fi, pas
print("Rang:", rang)

# Array amb valors espaiats uniformement
espaiats = np.linspace(0, 1, 5)  # Inici, fi, quantitat
print("Espaiats uniformement:", espaiats)</code></pre>

    <p><strong>Nota:</strong> Aquestes funcions s√≥n molt √∫tils per preparar dades per a experiments, simulacions o per crear estructures num√®riques base de manera r√†pida.</p>
  <hr>

    <h1>Indexaci√≥ i slicing avan√ßats</h1>

    <p>Amb NumPy pots accedir i modificar elements dels arrays utilitzant √≠ndexs o fins i tot condicions.</p>

    <pre><code>arrel = np.array([10, 20, 30, 40, 50])

# Acc√©s per √≠ndex
print("Element en l'√≠ndex 2:", arrel[2])  # 30

# Slicing (subarray)
print("Subarray:", arrel[1:4])  # [20 30 40]

# Condicionals
print("Elements majors que 25:", arrel[arrel > 25])  # [30 40 50]</code></pre>

    <h2>Operacions amb matrius</h2>
    <p>NumPy √©s molt eficient per a fer c√†lculs amb matrius, com el producte punt o la transposici√≥.</p>

    <pre><code>A = np.array([[1, 2], [3, 4]])
B = np.array([[5, 6], [7, 8]])

# Producte punt (matriu A ¬∑ matriu B)
print("Producte punt:\n", np.dot(A, B))

# Transposici√≥ de matriu A
print("Transposada de A:\n", A.T)</code></pre>

    <p><strong>Nota:</strong> El m√®tode <code>np.dot</code> calcula el producte matricial cl√†ssic, mentre que <code>A.T</code> retorna la transposada (intercanviant files per columnes).</p>

    <h2>Generaci√≥ de nombres aleatoris</h2>
    <p>NumPy ofereix diverses funcions per generar valors aleatoris de manera senzilla:</p>

    <pre><code># Nombre aleatori entre 0 i 1
aleatori = np.random.rand()
print("Nombre aleatori:", aleatori)

# Matriu aleat√≤ria d'enters
aleatoris = np.random.randint(1, 10, size=(3, 3))
print("Matriu aleat√≤ria:\n", aleatoris)</code></pre>

    <p>Aquestes funcions s√≥n √∫tils per simular dades, inicialitzar variables o fer proves estad√≠stiques.</p>

<hr>

    <h1>Per qu√® utilitzar NumPy?</h1>
    <p>NumPy √©s una biblioteca fonamental en Python per al c√†lcul num√®ric i l'an√†lisi de dades. Els principals motius per a utilitzar-la s√≥n:</p>
    <ol>
        <li><strong>Velocitat:</strong> NumPy pot ser fins a 50 vegades m√©s r√†pid que les llistes normals de Python per a operacions num√®riques gr√†cies al seu codi optimitzat en C.</li>
        <li><strong>Optimitzaci√≥ de mem√≤ria:</strong> Els arrays de NumPy utilitzen menys mem√≤ria que les estructures est√†ndard de Python.</li>
        <li><strong>Facilitat d‚Äô√∫s:</strong> Inclou moltes funcions matem√†tiques, estad√≠stiques i d‚Äô√†lgebra lineal que es poden utilitzar directament.</li>
        <li><strong>Interoperabilitat:</strong> Funciona perfectament amb altres biblioteques com <em>Pandas</em>, <em>Matplotlib</em>, <em>Scikit-learn</em>, entre altres.</li>
    </ol>

    <h2>Altres biblioteques en Python</h2>

    <h3>Incloses en la biblioteca est√†ndard</h3>
    <ul>
        <li><strong>os:</strong> Per a interactuar amb el sistema operatiu (crear carpetes, llegir fitxers, etc.).</li>
        <li><strong>sys:</strong> Per accedir a informaci√≥ del sistema i dels arguments passats al programa.</li>
        <li><strong>json:</strong> Per llegir i escriure dades en format JSON.</li>
        <li><strong>datetime:</strong> Per gestionar dates i hores.</li>
        <li><strong>math:</strong> Proporciona funcions matem√†tiques avan√ßades com arrels quadrades, trigonometria, etc.</li>
        <li><strong>decimal:</strong> Per a c√†lculs de precisi√≥ elevada, √∫til en contextos financers.</li>
        <li><strong>random:</strong> Per generar nombres aleatoris.</li>
        <li><strong>re:</strong> Per treballar amb expressions regulars (regex).</li>
        <li><strong>collections:</strong> Ofereix estructures de dades avan√ßades com <code>Counter</code>, <code>deque</code>, <code>defaultdict</code>, etc.</li>
        <li><strong>itertools:</strong> Funcions per manipular iteradors de forma eficient.</li>
        <li><strong>sqlite3:</strong> Per gestionar bases de dades SQLite de forma directa en Python.</li>
    </ul>
    <p>Pots veure tots els m√≤duls disponibles amb <code>help()</code> dins de l‚Äôint√®rpret de Python, i despr√©s escriure <code>modules</code>.</p>

    <h3>Biblioteques externes populars</h3>
    <ul>
        <li><strong>NumPy:</strong> Per a c√†lculs num√®rics r√†pids i eficients.</li>
        <li><strong>Pandas:</strong> Per al tractament de dades tabulars (com taules, fulls de c√†lcul, etc.).</li>
        <li><strong>Matplotlib:</strong> Per crear gr√†fics i visualitzacions b√†siques.</li>
        <li><strong>Seaborn:</strong> Basada en Matplotlib, permet crear gr√†fics estad√≠stics atractius i senzills.</li>
        <li><strong>Scikit-learn:</strong> Llibreria per a aprenentatge autom√†tic (machine learning).</li>
        <li><strong>Flask</strong> i <strong>Django:</strong> Frameworks per a desenvolupament web amb Python.</li>
        <li><strong>Requests:</strong> Per fer peticions HTTP com GET, POST, etc.</li>
        <li><strong>BeautifulSoup:</strong> Per fer <em>web scraping</em> (extracci√≥ d‚Äôinformaci√≥ de p√†gines web).</li>
        <li><strong>TensorFlow</strong> i <strong>PyTorch:</strong> Llibreries potents per a intel¬∑lig√®ncia artificial i <em>deep learning</em>.</li>
        <li><strong>Typer:</strong> Per crear interf√≠cies de l√≠nia de comandes (CLI) de forma r√†pida i elegant.</li>
        <li><strong>OpenCV:</strong> Per a processament d‚Äôimatges i visi√≥ artificial.</li>
        <li><strong>Pillow:</strong> Per a manipulaci√≥ d‚Äôimatges (redimensionar, retallar, etc.).</li>
        <li>...i moltes m√©s.</li>
    </ul>

    <p><strong>Nota:</strong> Les biblioteques externes s‚Äôinstal¬∑len normalment amb <code>pip</code>, per exemple: <code>pip install numpy</code>.</p>

</section>

<section id="dates">

      <h1>Dates en Python</h1>
      <p>Python inclou de manera nativa eines per al tractament de dates i hores mitjan√ßant el m√≤dul est√†ndard <code>datetime</code>. Aquest m√≤dul ve integrat en Python i no necessites instal¬∑lar cap llibreria addicional per utilitzar-lo.</p>
  
      <h2>Importar el m√≤dul datetime</h2>
      <pre><code>from datetime import datetime, timedelta, date</code></pre>
  
      <h2>Obtenir la data i hora actuals</h2>
      <p><strong>Data i hora actuals:</strong></p>
      <pre><code>ahora = datetime.now()
  print("Data i hora actual:", ahora)</code></pre>
  
      <p><strong>Nom√©s la data actual:</strong></p>
      <pre><code>hoy = date.today()
  print("Data actual:", hoy)</code></pre>
  
      <h2>Crear una data o hora espec√≠fica</h2>
      <p><strong>Crear una data espec√≠fica:</strong></p>
      <pre><code>mi_fecha = datetime(2025, 1, 28)  # Any, mes, dia
  print("Data espec√≠fica:", mi_fecha)</code></pre>
  
      <p><strong>Crear una data i hora espec√≠fica:</strong></p>
      <pre><code>mi_fecha_hora = datetime(2025, 1, 28, 14, 30, 0)  # Any, mes, dia, hora, minut, segon
  print("Data i hora espec√≠fica:", mi_fecha_hora)</code></pre>
  
      <h2>Format de dates (<code>strftime</code>)</h2>
      <p>Pots convertir una data o hora en un format espec√≠fic com a text:</p>
      <pre><code>formato = ahora.strftime("%d/%m/%Y %H:%M:%S")
  print("Format personalitzat:", formato)</code></pre>
  
      <h3>Exemples de codis de format:</h3>
      <ul>
          <li><code>%Y</code> - Any complet (2025)</li>
          <li><code>%m</code> - Mes en n√∫mero (01)</li>
          <li><code>%d</code> - Dia (28)</li>
          <li><code>%H</code> - Hora en format de 24 hores</li>
          <li><code>%I</code> - Hora en format de 12 hores</li>
          <li><code>%M</code> - Minut</li>
          <li><code>%S</code> - Segon</li>
          <li><code>%p</code> - AM o PM</li>
      </ul>

      <!DOCTYPE html>

          <h1>Convertir i Operar amb Dates en Python</h1>
      
          <h2>Convertir text en data (<code>strptime</code>)</h2>
          <p>Pots convertir una cadena de text en un objecte <code>datetime</code>:</p>
          <pre><code>texto = "28/01/2025 14:30:00"
      fecha_convertida = datetime.strptime(texto, "%d/%m/%Y %H:%M:%S")
      print("Text convertit a data:", fecha_convertida)</code></pre>
      
          <h2>Operacions amb dates</h2>
          <p>Aqu√≠ tens algunes operacions que pots realitzar amb dates:</p>
      
          <h3>1. Afegir o restar temps amb <code>timedelta</code>:</h3>
          <p><strong>Afegir 10 dies a la data actual:</strong></p>
          <pre><code>nueva_fecha = ahora + timedelta(days=10)
      print("Data amb 10 dies m√©s:", nueva_fecha)</code></pre>
      
          <p><strong>Restar 5 hores:</strong></p>
          <pre><code>nueva_hora = ahora - timedelta(hours=5)
      print("Data amb 5 hores menys:", nueva_hora)</code></pre>
      
          <h3>2. Calcular la difer√®ncia entre dues dates:</h3>
          <pre><code>fecha1 = datetime(2025, 1, 28)
      fecha2 = datetime(2025, 2, 5)
      diferencia = fecha2 - fecha1
      print("Dies de difer√®ncia:", diferencia.days)</code></pre>
      
          <h2>Comparar dates</h2>
          <p>Pots utilitzar operadors de comparaci√≥ com <code>&lt;</code>, <code>&gt;</code>, <code>==</code> per comparar objectes de data i hora:</p>
          <pre><code>if fecha1 < fecha2:
          print("Fecha1 √©s anterior a Fecha2")
      else:
          print("Fecha1 √©s posterior o igual a Fecha2")</code></pre>
      

          <h1>Altres M√≤duls Relacionats amb Dates en Python</h1>
      
          <h2>M√≤dul <code>time</code></h2>
          <p>El m√≤dul <code>time</code> s'utilitza per treballar amb el temps del sistema i realitzar operacions com mesurar intervals o fer pauses.</p>
          <h3>Caracter√≠stiques principals:</h3>
          <ul>
              <li>Gesti√≥ de <strong>timestamps</strong> (segons des de l'Epoch, 1 de gener de 1970).</li>
              <li>Realitzar pauses en l'execuci√≥ del programa.</li>
          </ul>
      
          <h3>Exemple b√†sic:</h3>
          <pre><code>import time
      
      # Pausar l'execuci√≥ per 2 segons
      time.sleep(2)
      
      # Obtenir el timestamp actual
      timestamp = time.time()
      print("Timestamp actual:", timestamp)</code></pre>
      
          <h2>M√≤dul <code>calendar</code></h2>
          <p>Aquest m√≤dul √©s √∫til per treballar amb calendaris i verificar propietats de dates (com dies de la setmana, anys bessis, etc.).</p>
          <h3>Caracter√≠stiques principals:</h3>
          <ul>
              <li>Generar calendaris en text o HTML.</li>
              <li>Verificar si un any √©s bisiest.</li>
              <li>Obtenir el primer dia de la setmana i el nombre de dies en un mes.</li>
          </ul>
      
          <h3>Exemple b√†sic:</h3>
          <pre><code>import calendar
      
      # Verificar si un any √©s bisiest
      print("¬ø2024 √©s bisiest?", calendar.isleap(2024))
      
      # Obtenir el calendari de gener 2025
      print(calendar.month(2025, 1))</code></pre>
      
          <h2>M√≤dul <code>zoneinfo</code> (Python 3.9+)</h2>
          <p>Aquest m√≤dul permet gestionar zones hor√†ries de manera m√©s senzilla i eficient.</p>
          <h3>Caracter√≠stiques principals:</h3>
          <ul>
              <li>Treballar amb zones hor√†ries espec√≠fiques.</li>
              <li>Convertir temps entre zones hor√†ries.</li>
          </ul>
      
          <h3>Exemple b√†sic:</h3>
          <pre><code>from datetime import datetime
      from zoneinfo import ZoneInfo
      
      # Definir zones hor√†ries
      utc = datetime.now(ZoneInfo("UTC"))
      madrid = datetime.now(ZoneInfo("Europe/Madrid"))
      
      print("Hora UTC:", utc)
      print("Hora Madrid:", madrid)</code></pre>
      
          <h2>Llibreries externes (opcionals)</h2>
          <p>Tot i que Python inclou eines robustes per gestionar dates, de vegades pots necessitar llibretes externes per a casos m√©s complexos. Les m√©s populars s√≥n:</p>
          <ul>
              <li><strong>dateutil</strong></li>
              <li><strong>arrow</strong></li>
          </ul>

</section>

<section id="exercicis">
  <h1>Exercicis</h1>
  <h3>Els exercicis i tests corresponents a esta unitat es troben en Aules</h3>
</section>

</main>

<script>

  // Per poder copiar codi en el porta-retalls. S'ha de posar un bot√≥ en cada <pre>
      //  <div class="pre-container">
      //    <button class="copy-button">Copia Codi !</button>
  document.addEventListener('DOMContentLoaded', function () {
    const buttons = document.querySelectorAll('.copy-button');

    buttons.forEach(button => {
      button.addEventListener('click', function () {
        const code = this.nextElementSibling.innerText;
        navigator.clipboard.writeText(code).then(() => {
          this.innerText = ' ‚úî Copiat!';
          setTimeout(() => this.innerText = 'Copia Codi !', 3000);
        });
      });
    });
  });

</script>

</body>
</html>
