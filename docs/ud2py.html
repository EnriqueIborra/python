<!DOCTYPE html>
<html lang="ca-ES">  
  <!--  al ponerlo en catalan, fuerzo al navegador a poner el traductor-->
  <!-- es-ES  lenguaje - ubicacion    -->
<head>
  <meta charset="UTF-8">
  <link rel="alternate" hreflang="ca-ES">
  <link rel="icon" href="https://www.python.org/favicon.ico"> 
  <title> Introducci√≥ a la programaci√≥</title>
  <link rel="stylesheet" href="estilsunitatspy.css">
  <link rel="stylesheet" href="https://cdn.hugeicons.com/font/hgi-stroke-rounded.css" />
</head>
<body>

  <header>
    <a href="index.html"><img src="imgs/phyton2-rbg.png" alt="python"></a>
    <h1>Unitat Did√†ctica 2: Estructures de control</h1>
    <h1> </h1>
  </header>

<nav>
  <h3>√çndex</h3>
 
  <a href="#estructures">Estructures de control</a>
  <a href="#salts">Salts en Python</a>
  <a href="#excepcions">Excepcions</a>
  <a href="#funcionsi">Funcions incorporades</a>
  <a href="#funcionsp">Funcions personalitzades</a>
  <a href="#moduls">Moduls i paquets</a>
  <a href="#main">√ös de __main__ </a>
  <a href="#ascii">ASCII / Unicode </a>
  <a href="#exercicis">Exercicis</a>
  
</nav>

<main>

<section id="estructures">

      <h1>Estructures de Control en Python</h1>
        <h2>Execuci√≥ Seq√ºencial</h2>
        
        <p>            L'execuci√≥ seq√ºencial √©s el comportament per defecte en un programa Python, on les instruccions es processen en l'ordre en qu√® apareixen al codi. 
          En altres paraules, les l√≠nies de codi s'executen de dalt a baix, una per una, sense saltar-se cap instrucci√≥.         </p>
      
        <h3>Exemple d'Execuci√≥ Seq√ºencial</h3>
        <p>           Quan s'executa un programa, el flux de control segueix una seq√º√®ncia lineal. Aqu√≠ tens un exemple senzill:         </p>
      
        <pre><code># Programa d'exemple per a execuci√≥ seq√ºencial
nombre = "Maria"
edat = 25

print("Hola, el meu nom √©s", nombre)  <!-- Imprimeix el nom -->
print("Tinc", edat, "anys.")           <!-- Imprimeix l'edat -->   
        </code></pre>
      
        <img src="imgs/sequencial.png" alt="sequencial" class="imatge-dreta" width="15%">
        <p>           En aquest exemple, el programa executa primer la l√≠nia on es defineix el nom, despr√©s imprimeix el nom, i finalment imprimeix l'edat. 
          No hi ha condicions ni bucles, per tant, cada instrucci√≥ es fa de manera seq√ºencial.         </p>
      
        <h3>Fluxe de Control</h3>
        
        <p>      En l'execuci√≥ seq√ºencial, el flux de control sempre segueix el codi de dalt a baix. No hi ha salts de l√≠nia ni condicions que puguin alterar aquest ordre.         </p>
        <p>           Aix√≤ √©s el que fa que el programa siga molt senzill de comprendre i mantenir en comparaci√≥ amb programes m√©s complexos que utilitzen altres estructures de control com condicions, bucles o funcions.         </p>
        <p>       L'execuci√≥ seq√ºencial √©s la forma m√©s b√†sica d'execuci√≥ en un programa. Cada l√≠nia s'executa una darrere de l'altra. Encara que aquest tipus d'execuci√≥ √©s √∫til per a programes senzills, la majoria de programes utilitzen estructures de control com <code>if</code>, <code>for</code>, <code>while</code>, etc., per gestionar fluxos de control m√©s complexos.         </p>
      
         <hr>
        <img src="imgs/condicional.png" alt="condicional" class="imatge-dreta" width="35%">
        <h2>Execuci√≥ Condicional (if, elif, else)</h2>
      <p> Les estructures condicionals permeten executar blocs de codi segons les condicions que s'hi especifiquen. 
        El operador <code>:</code> marca l'inici d'un bloc de codi estructurat i indentat, i √©s essencial perqu√® Python interprete correctament la jerarquia del programa.       </p>
      <p> La indentaci√≥ s'indica amb 4 espais (m√≠nim) o un tabulador. Aquest principi √©s fonamental en Python, ja que defineix l'estructura del programa, a difer√®ncia d'altres llenguatges que utilitzen claus <code>{}</code>.       </p>
      <p>A Python la indentaci√≥ no √©s nom√©s est√®tica, √©s part de la sintaxi, i sense ella el codi simplement no funciona.</p>
      La indentaci√≥ no nom√©s s‚Äôusa en un if, sin√≥ en tots els blocs de codi on cal indicar jerarquia o depend√®ncia. √âs una part fonamental de la sintaxi. 
      S'usa tamb√© en: Bucles for i while, Funcions (def), Excepcions (try, except, finally), match-case, Classes (class), Blocs with 
    
      <h3>Exemple d'√∫s del condicional if - else</h3>
      <pre><code>edat = int(input('Quina edat tens ? '))
if edat >= 18:
    print("Eres major d'edat")     # aquesta ordre est√† indentada
    print("==================")    # aquestes ordres formen un bloc
else:
    print("Eres menor d'edat")  # aquesta ordre tamb√© est√† indentada        </code></pre>

  <h3>Exemple d'√∫s del condicional if amb elif i  else</h3>      
      <pre><code>n = float(input("Quina nota has tret en l'examen?"))
if n<=4:
    print ("Suspes")
elif n<=6:
    print("Aprovat")
elif n<=8:
    print("Notable")
else:
    print("Excelent")          </code></pre>            

      
      <h3>Condicional en una sola l√≠nia</h3>
      <p>
        Si la estructura nom√©s t√© una l√≠nia, no √©s necessari indentar, tot i que √©s habitual fer-ho aix√≠:
      </p>
      <pre><code> if edat >= 18: print("Eres major d'edat")        </code></pre>

  

      <h2>Condicional Ternari en Python</h2>
      <p>Aquesta estructura permet assignar un valor a una variable segons una condici√≥ en una sola l√≠nia de codi, evitant aix√≠ la necessitat de tenir un bloc de codi amb m√∫ltiples l√≠nies.</p>   
  
      <h3>Sintaxi:</h3>
      <pre><code>valor_si_veritable if condici√≥ else valor_si_fals</code></pre>
    
      <h3>Exemple:</h3>
      <pre><code>edad = 20  # Exemple d'edat, o edad=input('Dis-me edad:')
missatge = "Major d'edat" if edad >= 18 else "Menor d'edat"
print(missatge)  # Eixida: Major d'edat         </code></pre>
  
      <ul>
          <li>Si l'edat (<code>edad</code>) √©s 18 o m√©s, la variable <code>missatge</code> rep el valor <code>"Major d'edat"</code>.</li>
          <li>Si l'edat √©s menor a 18, la variable <code>missatge</code> rep el valor <code>"Menor d'edat"</code>.</li>
      </ul>
      <p>Tamb√© es pot posar dins del <code>print</code></p>
      <pre><code>print ( "Major" if edat>18 else "Menor")</code></pre>

      <hr><h2>match-case</h2>
      <p>Des de Python 3.10 est√† disponible la instrucci√≥ <code> match-case</code>, una estructura pareguda al <code>switch</code> (d'altres llenguatges)</p>
      <pre><code>value = int(input("Dona'm un valor sencer: "))
match value:
    case 1:
        print ( "Uno" )
    case 2:
        print ( "Dos" )
    case 3:
        print ( "Tres" )
    case _:
        print ( "Otro valor" )        </code></pre>
    <p>case _: funciona com <strong> default </strong></p> <br>
      
      <pre><code>value = int(input("Dona'm un valor sencer: "))
match value:
    case 1 | 2:
        print ( "Uno o Dos" )
    case 3:
        print ( "Tres" )
    case _:
        print ( "Otro valor mayor que 3" )       </code></pre>
<p>En un <code>case</code> es poden posar m√©s d'un valor, separant amb <code>|</code></p>

    <hr>
      <h2>Guia de Estils de Python (PEP 8)</h2>
      <p>
        El moment de definir la indentaci√≥ √©s una bona ocasi√≥ per parlar de les guies d'estil oficials per al codi Python. 
        El document <a href="https://recursospython.com/pep8es.pdf" target="_blank">PEP 8</a> (Python Enhancement Proposals) estableix les millors pr√†ctiques per tal de fer el codi m√©s llegible, consistent i mantenible.
      </p>
    
      <h3>Principals Regles de PEP 8</h3>
      <ul>
        <li><strong>Indentaci√≥:</strong> Utilitzar 4 espais per nivell d'indentaci√≥ (no tabulacions).</li>
        <li><strong>L√≠nies de codi:</strong> M√†xim 79 car√†cters per l√≠nia.</li>
        <li><strong>Espais en blanc:</strong>
          <ul>
            <li>Un espai abans i despr√©s dels operadors (a = b + c).</li>
            <li>No espais dins dels par√®ntesis (func(a, b)).</li>
          </ul>
        </li>
        <li><strong>Noms de variables i funcions:</strong>
          <ul>
            <li>Variables i funcions: <em>snake_case</em> (exemple: mi_variable).</li>
            <li>Classes: <em>camelCase</em> (exemple: miClasse).</li>
          </ul>
        </li>
        <li><strong>Importacions:</strong>
          <ul>
            <li>Cada importaci√≥ en una l√≠nia (import os).</li>
            <li>Primer les llibreries est√†ndard, despr√©s les de tercers i al final les del projecte.</li>
          </ul>
        </li>
        <li><strong>Comentaris:</strong> Han de ser clars i concisos, preferiblement en angl√®s.</li>
      </ul>

  <br><br><hr><hr>
<img src="imgs/bucle.png" alt="bucles" class="imatge-dreta" width="20%">
<h1>Bucles (for, while) en Python</h1>
    <p>Els bucles s√≥n una estructura essencial en la programaci√≥ que permet repetir un conjunt d'operacions m√∫ltiples vegades.</p>

    <h2>1. Bucles <code>for</code></h2>
    <p>El bucle <code>for</code> <strong>itera</strong> sobre una secu√®ncia (com una llista o un rang). Aqu√≠ tens alguns exemples:</p>
    
    <h3>Exemple 1: Iteraci√≥ amb <code>range</code></h3>
    <p>La funci√≥ <code>range</code> √©s una eina molt √∫til a Python per generar una seq√º√®ncia d'elements. Aquesta seq√º√®ncia es pot utilitzar en 
      estructures de control de flux com el bucle <code>for</code> per realitzar iteracions de manera eficient.</p>
<pre><code>for i in range(5):  # Des de 0 fins a 4
    print(i)</code></pre>

    <h3>Exemple 2: Iteraci√≥ amb <code>range</code> amb l√≠mits espec√≠fics</h3>
<pre><code>for i in range(2, 5):  # Des de 2 fins a 4   ü§îRecorda al rebanat !!
    print(i)</code></pre>

    <h3>Exemple 3: Iteraci√≥ amb un pas definit</h3>
<pre><code>for i in range(2, 10, 2):  # Des de 2 fins a 8 amb pas 2
    print(i)</code></pre>

    <h3>Exemple 4: Iteraci√≥ cap enrere </h3>
<pre><code>for i in range(12, 7, -1):  # Des de 12 fins a 8 amb compte enrere
    print(i)</code></pre>    

    <h3>Exemple 5: Iteraci√≥ sobre una cadena (string)</h3>
<pre><code>for lletra in "Python":
    print(lletra)
</code></pre>

    <h3>Exemple 6: Iteraci√≥ sobre una llista</h3>
<pre><code>colla = ["Pikachu", "Charizard", "Bulbasaur"]    # A√ß√≤ √©s una llista, que es vor√† m√©s endavant
for i in colla:
    print(i)</code></pre>

    <h3>Paraules clau dins d'un bucle <code>for</code>:</h3>
    <ul>
        <li><strong><code>break</code></strong>: surt del bucle prematurament.</li>
        <li><strong><code>continue</code></strong>: salta la iteraci√≥ actual i continua amb la seg√ºent.</li>
        <li><strong><code>else</code></strong>: s'executa si el bucle no termina amb un <code>break</code>.</li>
    </ul>

    <h2>2. Bucles <code>while</code></h2>
    <p>El bucle <code>while</code> executa una acci√≥ (bloc de codi) mentre una condici√≥ siga certa (True).</p>
    <pre>while condicio:
    # codi que es repeteix
    # poden ser una o m√©s l√≠nies
    # No pot quedarse buit (sense codi)
    </pre>
    <ul>Com funciona
    <li>S'evalua la condici√≥: una expressi√≥ que retorna True o False</li>
    <li>Si √©s True, el codi del bucle s‚Äôexecuta</li>
    <li>Quan s'acaba el codi del bucle, es torna a comprovar la condici√≥ (salt al while)</li>
    </ul>
    
    <h3>Exemple: Bucles <code>while</code></h3>
    <pre><code>contador = 0
while contador < 5:
    print(f"Contador: {contador}")
    contador += 1  # Augmenta el contador
print(f"El contador despr√©s d'acabar el while val: {contador}")  </code></pre>    
    <ol> Resum:
    <li><code>while</code> repeteix codi metre la <code>condicio</code> siga <code>True</code></li>
    <li>S'ha de vigilar de no crear bucles infinits (incrementar comptador, introduir valors nous cada iteraci√≥, etc...)</li>
    <li>√âs √∫til quan no se sap quantes repeticions faran falta (a difer√®ncia de <code>for</code> ) </li>
    </ol>
    <p>Els bucles <code>for</code> i <code>while</code> s√≥n molt √∫tils per repetir accions m√∫ltiples vegades i controlar el flux de l'execuci√≥ dels programes en funci√≥ de condicions espec√≠fiques.</p>
    <hr>

 <h1> Cl√†usula <code>else</code> en bucles en Python</h1>

  <p>Aquesta t√®cnica de fer servir <code>else</code> despr√©s d‚Äôun bucle <code>while</code> o <code>for</code> en Python s‚Äôanomena:</p>

  <h2><strong>‚ñ∂Ô∏è Cl√†usula <code>else</code> en bucles</strong> <em>(Loop else clause)</em></h2>

  <h2> Descripci√≥:</h2>
  <p>√âs una <strong>caracter√≠stica pr√≤pia de Python</strong> (i poc comuna en altres llenguatges) que permet executar un bloc de codi <strong>quan el bucle s'acaba sense un <code>break</code></strong>.</p>

  <h2> Es pot aplicar a:</h2>
  <ul>
    <li><code>while</code> + <code>else</code></li>
    <li><code>for</code> + <code>else</code></li>
  </ul>

  <h2> Per qu√® √©s √∫til?</h2>
  <p>Permet distingir entre:</p>
  <ul>
    <li>Casos on <strong>s‚Äôha recorregut tot el bucle</strong> sense trobar res especial</li>
    <li>Casos on <strong>s‚Äôha interromput amb <code>break</code></strong></li>
  </ul>

  <h2> Exemple t√≠pic:</h2>
  <pre><code>for numero in [1, 3, 5, 7]:
    if numero % 2 == 0:
        print("T√© un nombre parell")
        break
else:
    print("Cap nombre parell trobat")</code></pre>

  <p><strong>üîπ Resultat:</strong> Si no es troba cap parell, s‚Äôexecuta l‚Äô<code>else</code>.</p>

<hr><h2>Estructura de Control de Flux: <code>pass</code></h2>
<p>El <code>pass</code> √©s una instrucci√≥ que es pot utilitzar com a marcador de lloc. Serveix quan cal una sintaxi v√†lida per√≤ no es vol que el codi faci res en una part espec√≠fica.</p>

<h3>Exemple d'√∫s de <code>pass</code></h3>
<pre><code>if condici√≥n:
    pass  # No hace nada, pero se puede dejar como espacio para agregar c√≥digo m√°s tarde</code></pre>
<p>El <code>pass</code> √©s √∫til quan necessites una sintaxi v√†lida sense que el codi realitzi cap acci√≥.</p>

          
</section>

<section id="salts">
 <h1>Salts en Python</h1>

  <p>En Python <strong>es poden fer salts en el flux d'execuci√≥</strong>, per√≤ <strong>d'una manera limitada i controlada</strong>. <br>
    Python <strong>no t√© una instrucci√≥ <code> üö´gotoüö´ </code></strong>, com altres llenguatges antics (C, BASIC...), per√≤ pots modificar el flux amb altres estructures.</p>

  <h2>üîÄ Maneres de fer "salts" en Python</h2>

  <h3>1. <code>break</code></h3>
  <p>Surt d‚Äôun bucle (<code>for</code> o <code>while</code>) immediatament.</p>
  <pre><code>for i in range(10):
    if i == 5:
        break
    print(i)
# Resultat: 0, 1, 2, 3, 4
</code></pre>

  <h3>2. <code>continue</code></h3>
  <p>Salta a la <strong>seg√ºent iteraci√≥</strong> del bucle, sense executar la resta del codi de dins.</p>
  <pre><code>for i in range(5):
    if i == 2:
        continue
    print(i)
# Resultat: 0, 1, 3, 4
</code></pre>

  <h3>3. <code>return</code></h3>
  <p>Surt immediatament d‚Äôuna funci√≥ i pot retornar un valor.</p>
  <pre><code>def verifica(x):
    if x &lt; 0:
        return "Negatiu"
    return "Positiu o zero"
</code></pre>

  <h3>4. <code>raise</code></h3>
  <p>Fa un "salt" provocant una excepci√≥: trenca l'execuci√≥ normal.</p>
  <pre><code>def dividir(x, y):
    if y == 0:
        raise ValueError("No es pot dividir per zero")
    return x / y
</code></pre>

  <h2>üö´ No hi ha <code>goto</code> en Python</h2>
  <p>Python <strong>no permet <code>goto</code></strong> perqu√® va en contra dels principis de llegibilitat i claredat que promou el llenguatge. En lloc d‚Äôaix√≤, es recomana:</p>
  <ul>
    <li>Fer servir <strong>funcions</strong> i <strong>estructures condicionals</strong></li>
    <li>Organitzar el codi en <strong>blocs clars</strong></li>
    <li>Evitar duplicaci√≥ i repetici√≥ de l√≤gica</li>
  </ul>

  <h2>‚úÖ Alternatives recomanades</h2>
  <ul>
    <li>Usa <strong>funcions</strong> per evitar repetir codi</li>
    <li>Usa <code>break</code>/<code>continue</code> nom√©s quan t√© sentit i millora la claredat</li>
    <li>Escriu codi llegible, mantenible i estructurat</li>
  </ul>

</section>

<section id="excepcions">
        <h1>Manejador de Errors / Excepcions en Python</h1>
        <p>En el seg√ºent programa, poden donar-se dos errors</p>
        <pre><code>a=int(input('Dame un numero:  '))
print(f'La inversa de {a} es { 1/(a) }')
print(' ===  Fi del programa  ===')
</code></pre>
        <p>Si posem una lletra</p>
        <pre><code>Dame un numero:  t</code></pre>
<pre><code style="color: darkred;">Traceback (most recent call last):
  File "c:\Users\enrique\OneDrive - Conselleria d'Educaci√≥\_PYTHON\proves\_prova.py", line 2, in <module>
    a=int(input('Dame un numero:  '))
ValueError: invalid literal for int() with base 10: 't'</code></pre>
        <strong> ==>  I el programa es para....</strong>
        <p>L'√∫ltima l√≠nea no s'executa si es produeix un error. Cap l√≠nia despr√©s de l'error s'executar√†</p> <hr>
        <p>Si posem un 0</p>
<pre><code style="color: darkred;">Traceback (most recent call last):
  File "c:\Users\enrique\OneDrive - Conselleria d'Educaci√≥\_PYTHON\proves\_prova.py", line 5, in <module>
    print(f'La operacion resulta  {1/(a)}')
                                   ~^^~~
ZeroDivisionError: division by zero</code></pre>
<strong> ==>  I el programa es para....</strong> <hr>

        <p>En Python, utilitzem les estructures <code>try</code> i <code>except</code> per capturar i gestionar els errors que poden sorgir durant l'execuci√≥ d'un programa.</p>

        <h2>Exemple de Manejador d'Errors</h2>
        <pre><code>try:
    resultado = 10 / 0
except ZeroDivisionError:
    print("Error: No se puede dividir entre cero.")
else:
    print("La operaci√≥n ha sido correcta")
finally:
    print("Esta parte se ejecuta siempre")
print("Y por supuesto el programa continua despu√©s del try")</code></pre>

        <ul>
            <li><strong><code>try</code></strong>: S'intenta executar el codi dins d'aquesta secci√≥.</li>
            <li><strong><code>except</code></strong>: Si es produeix un error (en aquest cas, una divisi√≥ per zero), s'executa el codi dins d'aquesta secci√≥.</li>
            <li><strong><code>else</code></strong>: Sols si no es produeix cap error en el bloc <code>try</code>, s'executa el codi dins d'aquesta secci√≥.</li>
            <li><strong><code>finally</code></strong>: Aquesta secci√≥ s'executa sempre, independentment de si hi ha hagut un error o no.</li>
            <!--<li>El finally s‚Äôexecuta SEMPRE, fins i tot si el try no acaba normalment(return, break, exepci√≥ no capturada)</li> -->
        </ul>
      <h4>Millora al codi incial</h4>
<pre><code>try:
    a=int(input('Dame un numero: '))
    print(f'La inversa de {a} es {1/(a) }')
except ValueError:
    print('Introduce un numero, no una letra')
except ZeroDivisionError:
    print('division por 0....')
except Exception
    print('Otro error no previsto.')

print('=====  Fin del programa  ======')</code></pre>
   
<p>El manejador d'errors amb <code>try</code> i <code>except</code> √©s essencial per controlar excepcions i evitar que el programa es pare en cas d'errors inesperats. </p>
    

</section>

<section id="funcionsi">

    <h1>Funcions en Python</h1>
    <p>Les funcions en Python s√≥n blocs de codi que es poden reutilitzar per realitzar operacions espec√≠fiques.
         Aquestes poden ser :</p>
        <li><strong>Funcions incorporades</strong> (Built-In Functions) que Python proporciona per realitzar 
            operacions comunes com c√†lculs matem√†tics, conversions de tipus de dades, obtenci√≥ d'informaci√≥ del sistema, entre altres.</li>
        <li><strong>Funcions personalitzades</strong> Funcions definides per l'usuari</li>
    <h1>Funcions incorporades</h1>
    <h2>Conversi√≥ de tipus</h2>
    <p>Python inclou diverses funcions per convertir entre diferents tipus de dades:</p>
    <ul>
        <li><code>int()</code>: Converteix a un enter. <br>
        &nbsp;&nbsp;(string, float, bool, ‚Üí a int) </li>
        <li><code>float()</code>: Converteix a un n√∫mero decimal (float). <br>
        &nbsp;&nbsp;(string, int, bool, ‚Üí a float) </li></li>
        <li><code>str()</code>: Converteix a una cadena de text.</li>
        <li><code>bool()</code>: Converteix a un valor boole√† (<code>True</code> o <code>False</code>).</li>
        <li><code>bin()</code>: Converteix un enter a la seua representaci√≥ bin√†ria com a cadena.</li>
        <li><code>chr()</code>: Converteix un codi Unicode a <strong>un</strong> car√†cter.</li>
        <li><code>ord()</code>: Converteix <strong>un</strong> car√†cter a un codi Unicode.</li>
    </ul>
    <p> <strong>ASCII i Unicode </strong>Al final de la unitat hi ha una ampliaci√≥ d'este punt d'ASCII i Unicode</p>
    <pre><code>Exemples:  int("123") # 123 ,  int("-45") # -45 ,  int("1010", 2)  # 10 (binari)   , int("FF", 16) # 255 (hexadecimal) 
int(3.9)  # 3 (Trunca la part decimal (no arrodonix))    int(-3.9)  # -3  ,   int(True)  # 1   int(False)  # 0 
bool() ‚Üí False  per als valors: False, 0, 0.0, "" (cadena buida), [], (), {}, set() (estructures buides),  None 
A estos valors se'ls anomena <strong>(valors falsy)</strong>, a la resta, <strong>(valors truthy)</strong>
La resta (valors truthy) ‚Üí True. üìå Detall important: bool() no mira el contingut, nom√©s si el valor √©s ‚Äúbuit‚Äù o ‚Äúzero‚Äù. 
bool("False")  # True üòÖ </code></pre>

    <h2>Funcions √∫tils amb variables</h2>
    <p>Algunes funcions que es poden utilitzar per obtenir informaci√≥ sobre variables s√≥n:</p>
    <ul>
        <li><code>type(x)</code>: Retorna el tipus de la variable <code>x</code>.</li>
        <li><code>id(x)</code>: Retorna l'identificador √∫nic de l'objecte <code>x</code>.</li>
        <li><code>isinstance(x, int)</code>: Retorna <code>True</code> si <code>x</code> √©s una inst√†ncia de la classe especificada, en aquest cas, <code>int</code>.</li>
        <li><code>globals()</code>: Retorna un diccionari amb totes les variables globals.</li>
        <li><code>locals()</code>: Retorna un diccionari amb totes les variables locals.</li>
        <li><code>callable(nomfunc)</code>: Retorna <code>True</code> si <code>nomfunc</code> √©s una funci√≥ o un objecte que es pot cridar.</li>
    </ul>

    <h2>Funcions matem√†tiques</h2>
    <p>Python tamb√© inclou diverses funcions per realitzar c√†lculs matem√†tics:</p>
    <ul>
        <li><code>abs(x)</code>: Retorna el valor absolut de <code>x</code>.</li>
        <li><code>round(x) </code>: Retorna el valor de <code>x</code> arrodonit a l'enter m√©s proper. <br>
            (Python usa <strong>round half to even</strong> (arrodoniment bancari))</li>
        <li><code> round(x,d) </code>: Retorna el valor de <code>x</code> arrodonit al float amb <code>d</code> decimals m√©s proper. <br></li>
        <li><code>max(numeros)</code>: Retorna el valor m√†xim de la llista de <code>numeros</code>.</li>
        <li><code>min(numeros)</code>: Retorna el valor m√≠nim de la llista de <code>numeros</code>.</li>
        <li><code>sum(numeros)</code>: Retorna la suma de tots els elements de la llista de <code>numeros</code>.</li>
        <li><code>divmod(a, b)</code>: Retorna una tupla amb el quocient i el residu de la divisi√≥ de <code>a</code> per <code>b</code>.</li>
    </ul>

    <h2>Enlla√ßos d'inter√®s</h2>
    <p>Per a m√©s funcions √∫tils de Python, consulta la documentaci√≥ oficial: <a href="https://docs.python.org/es/3.13/library/functions.html" target="_blank">Funcions Built-In en Python</a></p>

    <h1>Funcions de Cadenes en Python</h1>
    <p>Python proporciona diverses funcions incorporades (Built-In Functions) per treballar amb cadenes de text. Aquestes funcions permeten realitzar operacions comunes com modificar el format de la cadena, cercar subcadenes, o fins i tot combinar cadenes.</p>

    <h2>Funcions comunes per treballar amb cadenes:</h2>
    <p class="alert"> Us de funcions:   'pedro'.upper()  v.upper()  <strike>upper(v)</strike>   pero‚Ä¶  len('sdfs')  <strike>v.len()</strike> str(335)</p>
    <ul>
        <li><code>upper()</code>: Retorna la cadena en maj√∫scules. <code>'pedro'.upper()</code> ‚Üí <strong>'PEDRO'</strong></li>
        <li><code>lower()</code>: Retorna la cadena en min√∫scules. <code>'PEDRO'.lower()</code> ‚Üí <strong>'pedro'</strong></li>
        <li><code>strip()</code>: Elimina els espais en blanc al principi i final de la cadena. <code>'   hola   '.strip()</code> ‚Üí <strong>'hola'</strong></li>
        <li><code>capitalize()</code>: Retorna la cadena amb la primera lletra en maj√∫scula. <code>'pedro perez'.capitalize()</code> ‚Üí <strong>'Pedro perez'</strong></li>
        <li><code>capitalize()</code>: i les altres TOTES en min√∫scules. <code>'pEdRo pERez'.capitalize()</code> ‚Üí <strong>'Pedro perez'</strong></li>
        <li><code>title()</code>: Retorna la cadena amb la primera lletra de cada paraula en maj√∫scula. <code>'pedro perez'.title()</code> ‚Üí <strong>'Pedro Perez'</strong></li>
        <li><code>isalpha()</code>: Retorna <code>True</code> si tots els car√†cters de la cadena s√≥n lletres. <code>'hola'.isalpha()</code> ‚Üí <strong>True</strong></li>
        <li><code>isdigit()</code>: Retorna <code>True</code> si tots els car√†cters de la cadena s√≥n d√≠gits. <code>'1234'.isdigit()</code> ‚Üí <strong>True</strong></li>
        <li><code>isalnum()</code>: Retorna <code>True</code> si tots els car√†cters de la cadena s√≥n lletres o d√≠gits. <code>'abc123'.isalnum()</code> ‚Üí <strong>True</strong></li>
        <li><code>isspace()</code>: Retorna <code>True</code> si tots els car√†cters de la cadena s√≥n espais en blanc. <code>'   '.isspace()</code> ‚Üí <strong>True</strong></li>
        <li><code>find(sub)</code>: Retorna l'√≠ndex de la primera aparici√≥ de la subcadena <code>sub</code>. Si no la troba, retorna -1. <code>'hola'.find('o')</code> ‚Üí <strong>1</strong></li>
        <li><code>index(sub)</code>: Similar a <code>find()</code>, per√≤ llan√ßa una excepci√≥ si no troba la subcadena. <code>'hola'.index('o')</code> ‚Üí <strong>1</strong></li>
        <li><code>count(sub)</code>: Retorna el nombre d'aparicions de la subcadena <code>sub</code> dins la cadena. <code>'hola mon'.count('o')</code> ‚Üí <strong>2</strong></li>
        <li><code>replace(old, new)</code>: Substitueix totes les aparicions de la subcadena <code>old</code> per <code>new</code>. <code>'hola'.replace('o', 'a')</code> ‚Üí <strong>'hala'</strong></li>
        <li><code>split(separator)</code>: Divideix la cadena en una llista de subcadenes utilitzant el separador especificat. <code>'a,b,c'.split(',')</code> ‚Üí <strong>['a', 'b', 'c']</strong></li>
        <li><code>join(iterable)</code>: Combina els elements d'un iterable (com una llista) en una cadena, separats per la cadena actual. <code>','.join(['a', 'b', 'c'])</code> ‚Üí <strong>'a,b,c'</strong></li>
        <li><code>startswith(prefix)</code>: Retorna <code>True</code> si la cadena comen√ßa amb el prefix especificat. <code>'hola'.startswith('ho')</code> ‚Üí <strong>True</strong></li>
        <li><code>endswith(suffix)</code>: Retorna <code>True</code> si la cadena acaba amb el sufix especificat. <code>'hola'.endswith('a')</code> ‚Üí <strong>True</strong></li>
        <li><code>format()</code>: Permet formatejar cadenes de text. <code>'Hola {}'.format('m√≥n')</code> ‚Üí <strong>'Hola m√≥n'</strong> (similar als f-strings)</li>
        <li><code>zfill(width)</code>: Omple la cadena amb zeros al principi fins a aconseguir la llargada especificada. <code>'42'.zfill(5)</code> ‚Üí <strong>'00042'</strong></li>
        <li><code>center(width)</code>: Centra la cadena en un camp de car√†cters de llargada especificada. <code>'hola'.center(8)</code> ‚Üí <strong>'&nbsp;&nbsp;hola&nbsp;&nbsp; '</strong></li>
        <li><code>ljust(width)</code>: Justifica la cadena a l'esquerra en un camp de llargada especificada. <code>'hola'.ljust(8)</code> ‚Üí <strong>'hola&nbsp;&nbsp;&nbsp;&nbsp; '</strong></li>
        <li><code>rjust(width)</code>: Justifica la cadena a la dreta en un camp de llargada especificada. <code>'hola'.rjust(8)</code> ‚Üí <strong>'&nbsp;&nbsp;&nbsp;&nbsp;hola'</strong></li>
    </ul>

    <h2>Nombres aleatoris</h2>
    <p>Els nombres aleatoris s√≥n nombres que es generen a l‚Äôatzar, √©s a dir, sense seguir cap patr√≥ previsible. 
        Cada nombre t√© la mateixa probabilitat de sortir, i no es pot saber quin ser√† el seg√ºent.</p>
    <ul> Exemples
        <li>Llan√ßar un dau: pot sortir 1, 2, 3, 4, 5 o 6 de manera aleat√≤ria.</li>
        <li>Traure una carta d‚Äôuna baralla barrejada.</li>
        <li>Un n√∫mero que genera un ordinador ‚Äúa l‚Äôatzar‚Äù entre 1 i 100.</li>
    </ul>

    <ul> Per a qu√® serveixen ?
        <li>Jocs (daus, cartes, videojocs)</li>
        <li>Estad√≠stica (mostres aleat√≤ries)</li>
        <li>Simulacions (predir el temps, experiments cient√≠fics)</li>
        <li>Inform√†tica i seguretat (contrasenyes, criptografia)</li>
    </ul>
    <p>Els ordinadors, en realitat, solen generar nombres pseudoaleatoris: semblen aleatoris, per√≤ provenen de c√†lculs matem√†tics.</p>
    <pre># En python : exemple
from random import randrange
x=randrange(1,21)   
   # genera un nombre aleatori entre 1 i 20 (inclosos)        </pre>

    <h2>Dates</h2>
    <p>Per poder treballar amb dates en python es necessita importar funcions espec√≠fiques. La primera que usarem per obtenir
        la data actual ser√† <code><strong>date</strong></code> i es pot vore un exemple de com utilitzar-la    </p>
    <pre>from datetime import date

avui = date.today()
print(avui)        # 2026-02-10 (per exemple)
print(avui.year)   # any
print(avui.month)  # mes
print(avui.day)    # dia    </pre>
<p>I per saber l'hora (minut, segon ) s'usar√† <code><strong>datetime</strong></code></p>
    <pre>from datetime import datetime
        
ara= datetime.now()
print(ara)
print(ara.hour)
print(ara.minute)
print(ara.second)  </pre>

<!--   <h2>Funci√≥ <code>eval()</code></h2>
    <p><code>eval()</code> √©s una funci√≥ que permet executar una cadena de text com a codi Python. Pot ser perillosa si s'utilitza amb dades no fiables, ja que pot executar qualsevol codi Python.</p>
    <p>Exemple d'√∫s:</p>
    <pre><code>eval('x+1')</code></pre>
    <p>Aquesta funci√≥ interpreta i executa la cadena <code>'x+1'</code>, avaluant-la com a codi Python.</p> -->

</section>



<section id="funcionsp">

        <h1>Funcions Definides per l'Usuari en Python</h1>
        <p>A m√©s de les funcions incorporades en el llenguatge, Python permet la definici√≥ de funcions noves, tamb√© conegudes com a funcions definides per l'usuari.</p>
        <p>Les funcions definides per l'usuari s√≥n blocs de codi reutilitzables que realitzen una tasca espec√≠fica. Aquestes funcions es creen utilitzant la paraula clau <code>def</code>, seguida del nom de la funci√≥ i par√®ntesis que poden incloure par√†metres. El cos de la funci√≥ est√† indentat i pot incloure declaracions, c√†lculs i una declaraci√≥ <code>return</code> per retornar un valor.</p>
    
        <h2>Exemple de Funci√≥ Definida per l'Usuari</h2>
        <pre><code># Definir funci√≥
def saluda():
    print("Hola mon")
    print("Soc Python !!")
    
# Cridar la funci√≥
saluda()      # Esta funci√≥ no retorna cap valor, sols imprimeix
              # En realitat torna el valor   None   </code> </pre>
        <pre><code>def sumaEsp(a, b):
    if a > b :        
       resultat = a + b + b + 1
    else:
       resultat = a + a + b + 2
    <strong>return</strong> resultat

# Cridar la funci√≥
resultat_suma = sumaEsp(3, 5)    # Esta funci√≥ no imprimeix res, pero torna un valor
print(resultat_suma)      # Eixida: 13
print ( sumaEsp ( 243, 521) )  # Eixida 1009
        </code></pre>
        <p>En aquest exemple, la funci√≥ <code>sumaEsp(a, b)</code> rep dos par√†metres, <code>a</code> i <code>b</code>,
             i retorna la seua suma "especial".</p>
    
        <h3>Components d'una Funci√≥ Definida per l'Usuari:</h3>
        <ul>
            <li><strong>Paraula clau <code>def</code>:</strong> S'utilitza per definir la funci√≥.</li>
            <li><strong>Nom de la funci√≥:</strong> Un nom descriptiu per a la funci√≥, seguit de par√®ntesis.</li>
            <li><strong>Par√†metres:</strong> Opcionalment, una funci√≥ pot rebre valors externs mitjan√ßant par√†metres.</li>
            <li>:  Els dos punts indiquen que comen√ßa el bloc de codi <strong>indentat</strong></li>
            <li><strong>Codi dins la funci√≥:</strong> Blocs d'instruccions que realitzen l'operaci√≥ desitjada. <strong>bloc indentat</strong></li>
            <li><strong>Declaraci√≥ <code>return</code>:</strong> Opcional, retorna un valor de la funci√≥.</li>
            Si una funci√≥ acaba i no executa l'ordre <code>return</code>, el valor de retorn es <code>None</code>
        </ul>
        <p>La indentaci√≥ fa refer√®ncia a la t√®cnica d'afegir espais al principi de les l√≠nies de codi, el que ajuda a delimitar visualment els blocs i les estructures de control.</p>
    
        <p>En Python, la indentaci√≥ √©s molt important ja que √©s la manera que utilitza el llenguatge per definir l'estructura del codi, a difer√®ncia d'altres llenguatges que utilitzen claus (<code>{}</code>) per identificar els blocs. Un codi sense una correcta indentaci√≥ pot generar errors d'execuci√≥ o de l√≤gica.</p>

    <h3>On / Quan definir les funcions</h3>    
    <p>S'ha de tindre en compte que, fins que no s'ha definit una funci√≥, no es pot fer servir. 
        Python llegir√† el codi de dalt a baix, i si encara no coneix la funci√≥‚Ä¶ => ‚ùå Error: <code>NameError</code>
    </p>
    <pre><code>resultat = suma(3, 5)   # ‚ùå ac√≠ encara no existeix
    
def suma(a, b):
    return a + b    </code></pre>
<pre><code>NameError: name 'suma' is not defined </code></pre>

    <p>Aix√≠ que, quan abans, millor. Si pot ser, al principi del codi.</p>
    <h3>Funcions amb Valor de Retorn</h3>
    <pre><code>def multiplicar(a, b):
    return a * b

resultat_multiplicacio = multiplicar(4, 3)
print(resultat_multiplicacio)  # Eixida: 12           </code></pre>

    <p>Les funcions tamb√© poden retornar un valor mitjan√ßant la declaraci√≥ <code>return</code>, com es veu en l'exemple de la funci√≥ <code>multiplicar</code>.</p>
    <p>Una funcio pot tindre m√©s d'una intrucci√≥ <code>return</code> , per√≤ sols s'executar√† una, que eixir√† de la funci√≥</p>
                 

    <h3>Funcions amb Par√†metres Opcionals</h3>
    <pre><code>def saludar(nom="Usuari"):
    print(f"Hola, {nom}!")

saludar("Joan")  # Eixida: Hola, Joan!
saludar()        # Eixida: Hola, Usuari!       </code></pre>

    <p>Aquest exemple mostra com es poden definir par√†metres opcionals en una funci√≥. Si no es passa cap valor a la funci√≥, es fa servir el valor per defecte (en aquest cas, <code>"Usuari"</code>).</p>
    <pre><code>def multiplicar(a=0, b=1):
    return a * b

resultat_multiplicacio = multiplicar(4, 3)
print(resultat_multiplicacio)  # Eixida: 12
print( multiplicar(4))  # Eixida: 4 
print( multiplicar())  # Eixida:  0           </code></pre>
        <p>Aquest exemple mostra com es poden definir par√†metres opcionals en una funci√≥. 
            Si no es passa cap valor a la funci√≥, tornar√† un 0, i si es passa sols un, tornar√† el mateix valor.</p>
   <p class="alert">si hi han alguns opcionals i altres obligat√≤ris , els par√†metres opcionals no poden estar els primers, sempre els ultims !! </p>
    <p>Regla important: Els par√†metres opcionals SEMPRE van despr√©s dels obligatoris</p>
    <pre><code>def exemple(a=1, b):   # ‚ùå Incorrecte:
    pass       </code></pre>

    <pre><code>def rectangle(ample, alt=10):    #  ‚úÖ Correcte:
    return ample * alt

print(rectangle(5))
print(rectangle(5, alt=3))   # en la cridada a la funci√≥ es pot especificar el nom del par√†metre !!</code></pre>
   
    <h3>Assignar funcions a variables</h3>
    <p>Aix√≤ permet passar-les com a par√†metres, guardar-les en estructures, etc.</p>
    <pre><code>def saludar():
    print("Hola!")

f = saludar      # En esta instrucci√≥ NO es crida la funci√≥ (no porta par√®ntesis)
f()              # Executa saludar()       </code></pre>

    <h3>Funcions amb Tipus de Dades (Type Hinting)</h3>
    <p>En Python, es poden afegir indicadors de tipus (type hints) per especificar el tipus de les variables o els arguments d'una funci√≥. Aix√≤ millora la llegibilitat del codi i ajuda als editors a proporcionar suggeriments i detecci√≥ d'errors.</p>
    <pre><code>def dividir(a: float, b: float) -> float:   # Indicaci√≥ de tipus per a arguments i valor de retorn
    return a / b              </code></pre>
        
    <h3>Funcions amb m√∫ltiples arguments</h3>
    <p>En Python, es poden definir funcions que accepten un nombre variable d'arguments usant els s√≠mbols <code>*</code> i <code>**</code>:</p>
    
    <h4>Arguments arbitraris (Amb Comes)</h4>
    <p>A priori, no se sap quants arguments es passaran. Seran diversos arguments passats amb comes.</p>
    <pre><code>def sumar_todos(*numeros):  # Diversos arguments passats amb comes
    return sum(numeros)              </code></pre>
    <p>En aquest exemple, la funci√≥ <code>sumar_todos</code> pot acceptar qualsevol nombre d'arguments, i els processa com una tupla.</p>
     <pre># Exemple de com usar la funci√≥
resultat = sumar_todos(1, 2, 3, 4)
print(resultat)   # Output: 10 

llista = [5, 6, 7]
resultat = sumar_todos(*llista)
print(resultat)   # Output: 18  </pre>

    <h4>Arguments amb clau i valor (Clave-Valor)</h4>
    <pre><code>def mostrar_info(**info):  # Diversos arguments passats com a clau-valor
    for clau, valor in info.items():
        print(f"{clau}: {valor}")                </code></pre>
    <p>Aquesta funci√≥ accepta un nombre arbitrari de parells de clau-valor, com un diccionari.</p>
    <pre># Exemple d'us
mostrar_info(nom="Anna", edat=25, ciutat="Barcelona")

dades = {"nom": "Marc", "edat": 30}
mostrar_info(**dades)      </pre>

    <h3>Funcions que retornen m√©s d'un valor</h3>
    <pre><code>def operacions(a, b):
    suma = a + b
    resta = a - b
    producte = a * b
    return suma, resta, producte

x,y,z = operacions(10,5)
resultat = operacions(10, 5)
print(resultat)        # (15, 5, 50)
</code></pre>

    <h3>Funcions Lambda</h3>
    <p>Les funcions lambda s√≥n funcions an√≤nimes que es poden definir en una sola l√≠nia. S√≥n √∫tils per a operacions simples i per passar com arguments a altres funcions.</p>
    <pre><code>multiplicar = lambda x, y: x * y  # Funci√≥ lambda per multiplicar dos valors
print(multiplicar(2, 3))  # Eixida: 6                </code></pre>
        
    <h3>Decoradors (Seg√ºent Tema)</h3>
    <p>Els decoradors en Python s√≥n una forma de modificar o millorar el comportament d'una funci√≥ sense canviar-ne el codi. S√≥n un tema avan√ßat que tractarem m√©s endavant.</p>
    <hr>
            
    <h1>√Åmbit o Scope en Python</h1>

    <p>En Python, l'√†mbit d'una variable es refereix a la regi√≥ del codi on una variable √©s accessible. Python t√© regles espec√≠fiques per determinar on una variable es pot utilitzar o modificar. Els √†mbits m√©s comuns s√≥n:</p>

    <h2>√Åmbit Local</h2>
    <p>Una variable definida dins d'una funci√≥ t√© un √†mbit local. Nom√©s pot ser accedida dins d'aquesta funci√≥. Si intentes accedir a una variable local fora de la seua funci√≥, obtindr√†s un error.</p>
    <h3>Exemple d'√†mbit local</h3>
    <pre><code>def funcion():
    y = 5  # Variable local
    print(y)  # Eixida: 5
funcion()
print(y)  # Error: NameError, 'y' no est√† definida en l'√†mbit global      </code></pre>

    <h2>√Åmbit Global</h2>
    <p>Una variable definida fora de totes les funcions o blocs de codi t√© un √†mbit global. Pot ser accedida des de qualsevol part del codi, incloent dins de les funcions.</p>
    <p class="alert">Per√≤, <strong>accedir</strong> no √©s el mateix que <strong>modificar</strong>.....</p>
    <p>Si es necessita modificar una variable global dins d'una funci√≥, s'ha d'utilitzar la paraula clau <code>global</code>.</p>

    <h3>Exemple de variable global</h3>
    <pre><code>x = 10  # Variable global
def mostrar_x():
    print(x)  # Acc√©s a la variable global
mostrar_x()  # Eixida: 10                    </code></pre>

    <pre><code>def mostrar_x():
    print(x)  # Acc√©s a la variable global

x = 10  # Variable global. No hi ha problema perqu√® es defineix abans de cridar a la funci√≥    
mostrar_x()  # Eixida: 10                    </code></pre>

    <h3>Modificaci√≥ d'una variable global dins d'una funci√≥ sense <code><strong>global</strong></code> (no es pot)</h3>
    <pre><code>x = 10
def modificar_x():
    x = 20  # Crea una nova variable local, no modifica la global
    print(x)  # Eixida: 20
modificar_x()
print(x)  # Eixida: 10 (la variable global no ha canviat)           </code></pre>
            
    <h3>Modificaci√≥ d'una variable global dins d'una funci√≥ amb <code><strong>global</strong></code></h3>
    <pre><code>x = 10
def modificar_x():
    global x
    x = 20  # Modifica la variable global
    print(x)  # Eixida: 20
modificar_x()
print(x)  # Eixida: 20 (la variable global ha canviat)       </code></pre>
       
        <h2>√Åmbit de Bucle o Bloc</h2>
        <p>En Python, els blocs (if, for, while) NO creen un nou √†mbit (scope). Nom√©s les funcions, classes i m√≤duls creen √†mbits nous.
        A difer√®ncia d'altres llenguatges, en Python les variables definides en un bucle o bloc no estan limitades a aquell bloc i poden ser accedides fora d'ell.</p>
        
        <h3>Exemple d'√†mbit de bucle</h3>
        <pre><code>for i in range(3):
    print(i)  # Eixida: 0, 1, 2
    x=10
print(i)  # Eixida: 2 (la variable 'i' segueix accessible fora del bucle)
print(x)  # Eixida: 10        </code></pre>
    <p>Aix√≤ pot resultar conf√∫s si vens d'altres llenguatges on les variables de bucle tenen un √†mbit limitat al bloc.</p>
            
    <h2>√Åmbit No Local (Nonlocal)</h2>
    <p>En python es poden definir funcions , dins d'altres funcions.</p>
    <p>L'√†mbit no local aplica a variables definides en una funci√≥ externa (per√≤ no global) i que es poden accedir des d'una funci√≥ interna (anidada). Per modificar una variable d'una funci√≥ externa dins d'una funci√≥ interna, es fa servir la paraula clau <code>nonlocal</code>.</p>

    <h3>Exemple de variable no local</h3>
    <pre><code>def funcion_externa():
    z = 15  # Variable no local
    def funcion_interna():
        nonlocal z
        z = 25  # Modifica la variable de la funci√≥ externa
        print(z)  # Eixida: 25
    funcion_interna()
    print(z)  # Eixida: 25 (la variable no local ha canviat)
funcion_externa()
        </code></pre>
    

    <hr>
    <h2>Bones Pr√†ctiques al Definir Funcions en Python</h2>

    <p>Quan es defineixen funcions en Python, hi ha algunes bones pr√†ctiques que ajuden a millorar la llegibilitat, mantenibilitat i efici√®ncia del codi:</p>

    <h3>1. Noms descriptius</h3>
    <p>El nom de la funci√≥ ha de reflectir clarament el seu prop√≤sit. Aix√≤ facilita la comprensi√≥ del codi i la seua reutilitzaci√≥.</p>

    <h3>2. Comentaris i documentaci√≥ (Docstrings)</h3>
    <p>√âs important documentar les funcions per explicar qu√® fan, quins s√≥n els par√†metres d'entrada i el valor de retorn. El millor m√®tode per documentar una funci√≥ √©s utilitzar <code>docstrings</code>, que es defineixen entre triple cometes (<code>""" ... """</code>).</p>
    
    <h4>Exemple de funci√≥ amb docstring</h4>
    <pre><code>def sumar(a, b):
    """
    Suma dos n√∫meros y devuelve el resultado.
    :param a: Primer n√∫mero
    :param b: Segundo n√∫mero
    :return: La suma de a y b
    """
    return a + b       </code></pre>
    <p>A m√©s a m√©s, esta forma de documentar permet activar l'ajuda de la funci√≥ definida</p>
    <pre>help(sumar)

sumar(a, b)
    Suma dos n√∫meros y devuelve el resultado.
    :param a: Primer n√∫mero
    :param b: Segundo n√∫mero
    :return: La suma de a y b             </pre>
          
    <h3>3. Evitar efectes secundaris</h3>
    <p>Una funci√≥ hauria de fer nom√©s una cosa. No hauria de modificar variables globals o tindre efectes secundaris inesperats. Aix√≤ ajuda a que el comportament de la funci√≥ siga m√©s previsible.</p>

    <h3>4. Mantindre les funcions curtes</h3>
    <p>Les funcions han de ser curtes i f√†cils de llegir. Si una funci√≥ √©s massa llarga, es recomana dividir-la en funcions m√©s petites per a fer-les m√©s comprensibles i reutilitzables.</p>
    <hr>
 
    <h2>√ös del Gui√≥ Baix (<code>_</code>) en Python</h2>

    <p>El gui√≥ baix (<code>_</code>) en Python t√© diversos usos depenent del context en qu√® es trobe. A continuaci√≥ es mostren alguns dels usos m√©s comuns:</p>

    <h3>1. Ignorar valors en assignacions</h3>
    <p>Es fa servir com una variable "desechable" quan no necessites utilitzar un valor en una assignaci√≥. El valor es descarta utilitzant el guion baix.</p>
            <pre><code>_, y, z = (1, 2, 3)
print(y, z)  # Eixida: 2 3</code></pre>
        
    <h3>2. Iteracions quan no es necessita el valor</h3>
    <p>En els bucles, es fa servir <code>for _ in range(n)</code> quan no necessites utilitzar la variable del bucle.</p>
    <pre><code>for _ in range(3):
    print("Hola")  # Es imprimeix "Hola" tres vegades</code></pre>

    <h3>3. √öltim resultat en la consola interactiva</h3>
    <p>En la terminal de Python, <code>_</code> emmagatzema l'√∫ltim resultat calculat.</p>
    <pre><code>>> 5 + 3
8
>>> _ * 2
16</code></pre>
        
    <h3>4. Prefixe per a variables privades</h3>
    <p>Es fa servir <code>_variable</code> per indicar que una variable √©s "privada" (aix√≤ √©s una convenci√≥, no una restricci√≥ real).</p>
    <pre><code>class MiClasse:
    def __init__(self):
            self._secreta = 42  # Indica que √©s privada (per√≤ encara accessible)</code></pre>
        
    <h3>5. Doble gui√≥ baix per evitar col¬∑lisions de noms (name mangling)</h3>
<p>Quan una variable comen√ßa amb <code>__</code>, Python canvia el seu nom internament per evitar col¬∑lisions.</p>
<pre><code>class Exemple:
def __init__(self):
    self.__privada = 99
        
e = Exemple()
print(dir(e))  # Es converteix en _Exemple__privada</code></pre>
        
    <h3>6. Utilitzar <code>_</code> en noms de funcions i variables per evitar conflictes</h3>
    <p>Es fa servir <code>_</code> en noms per evitar conflictes amb paraules clau de Python.</p>
    <pre><code>def class_(nom):
    return f"Classe: {nom}"</code></pre>
      <hr><p class="alert">En Python no hi ha pas per refer√®ncia, sin√≥ pas de refer√®ncies a objectes.
      Nom√©s els objectes mutables poden ser modificats dins d‚Äôuna funci√≥</p> 
     <hr><p class="alert">En Python una funci√≥ es pot cridar des de dins d'una altra funci√≥</p>     
      <hr><p class="alert">En Python una funci√≥ es pot cridar a si mateix ( <strong>recursivitat</strong> ) i possible DoS si no es fa b√©</p>  
</section>


<section id="moduls">

        <h2>M√≤duls i Paquets en Python</h2>
    
        <p>Un <strong> m√≤dul </strong> √©s simplement un fitxer de Python amb extensi√≥ <code>.py</code> que cont√© definicions de funcions, classes i variables. Pots reutilitzar el codi d'un m√≤dul important-lo en altres arxius o programes.</p>
    
        <h3>Crear un fitxer Python (mi_modulo.py)</h3>
        <pre><code># mi_modulo.py
def saludar(nombre):
    return f"Hola, {nombre}!"
PI = 3.14159</code></pre>
    
    <h3>Importar i utilitzar el m√≤dul en un altre arxiu</h3>
    <pre><code># programa.py
import mi_modulo
print(mi_modulo.saludar("Juan"))  # Eixida: Hola, Juan!
print(mi_modulo.PI)               # Eixida: 3.14159</code></pre>
    
    <p>Quan hem importat un m√≤dul i volem utilitzar algun element del mateix, hem de fer servir el seu espai de noms seguit d'un punt i el nom de l'element que volem utilitzar. L'espai de noms no √©s m√©s que el nom que hem indicat despr√©s del <code>import</code>.</p>

    <h3>Maneres d'importar m√≤duls:</h3>

    <h4>Importar tot el m√≤dul:</h4>
    <pre><code>import mi_modulo                # L'espai de noms √©s => mi_modulo
print(mi_modulo.saludar("Ana"))  # D'aquesta manera s'ha de fer servir l'espai de noms</code></pre>
    
    <h4>Importar elements espec√≠fics del m√≤dul: (sense espai de noms)</h4>
    <pre><code>from mi_modulo import saludar
print(saludar("Carlos"))       # D'aquesta manera NO s'ha de fer servir l'espai de noms</code></pre>
    
    <h4>Importar TOTS els elements del m√≤dul: (sense espai de noms)</h4>
    <pre><code>from mi_modulo import *
print(saludar("Carlos"))       # D'aquesta manera NO s'ha de fer servir l'espai de noms</code></pre>
    
    <h4>Renombrar un m√≤dul:</h4>
    <pre><code>import mi_modulo as mm
print(mm.PI)                # D'aquesta manera s'ha de fer servir l'espai de noms</code></pre>
     <hr>
    <h3>Paquets en Python</h3>

    <p>Un paquet √©s una col¬∑lecci√≥ de m√≤duls organitzats en un directori. Serveix per estructurar projectes grans en jerarquies de subm√≤duls.</p>

    <h4>Com crear un paquet:</h4>
    <ol>
        <li>Crea una carpeta per al paquet (per exemple, <code>mi_paquete</code>).</li>
        <li>Dins de la carpeta, afegeix un arxiu especial anomenat <code>__init__.py</code>. Aquest arxiu pot estar buit o contenir codi d'inicialitzaci√≥ per al paquet.</li>
    </ol>

    <h4>Estructura b√†sica d'un paquet:</h4>
    <pre><code>mi_paquete/
        __init__.py
        modulo1.py
        modulo2.py</code></pre>
    
        <h4>Exemple de m√≤duls dins del paquet:</h4>
        <h5>‚ó¶ <code>modulo1.py</code>:</h5>
        <pre><code>def sumar(a, b):
        return a + b</code></pre>
    
        <h5>‚ó¶ <code>modulo2.py</code>:</h5>
        <pre><code>def restar(a, b):
        return a - b</code></pre>
    
        <h3>√ös del paquet en un programa:</h3>
        <pre><code># programa.py
from mi_paquete.modulo1 import sumar
from mi_paquete.modulo2 import restar

print(sumar(5, 3))  # Eixida: 8
print(restar(5, 3)) # Eixida: 2</code></pre>
    
        <h3>Paquets niats:</h3>
        <p>Els paquets poden contenir subpaquets. Per exemple:</p>
        <pre><code>mi_paquete/
        __init__.py
        utilidades/
            __init__.py
            herramientas.py</code></pre>
    
        <p>Pots importar subm√≤duls aix√≠:</p>
        <pre><code>from mi_paquete.utilidades.herramientas import alguna_funcion</code></pre>
    <hr>
        <h3>M√≤duls i Paquets Est√†ndard de Python</h3>
    
        <p>Python inclou molts m√≤duls est√†ndard llestos per utilitzar. Alguns exemples comuns s√≥n:</p>
    
        <h4>Exemples de m√≤duls est√†ndard:</h4>
    
        <h5>‚Ä¢ <code>math</code>: Funcions matem√†tiques.</h5>
        <pre><code>import math
    print(math.sqrt(16))  # arrel quadrada ‚Üí 4.0
    print(math.pi)        # œÄ
    # altres funcions com:   sin, cos, tan, e, log, pow, factorial...  </code></pre>
    
        <h5>‚Ä¢ <code>os</code>: Operacions del sistema operatiu.</h5>
        <pre><code>import os
    print(os.getcwd())  # Obt√©n el directori actual.
    # altres funcions: chdir('..')  listdir() mkdir() ....   </code></pre>
    
        <h5>‚Ä¢ <code>random</code>: Generaci√≥ de n√∫meros aleatoris.</h5>
        <pre><code>import random
print(random.randint(1, 10))  # N√∫mero aleatori entre 1 i 10.
random.uniform(1, 10)  # float entre 1 i 10
random.random()        # float entre 0.0 i 1.0

llista = [1, 2, 3, 4, 5]
random.choice(llista)        # element aleatori
random.choices(llista, k=3)  # diversos elements (pot repetir)
random.sample(llista, 3)     # elements √∫nics
random.shuffle(llista)       # Barrejar llista

# Exemples per a Jocs i simulacions
dau = random.randint(1, 6)
moneda = random.choice(["cara", "creu"])  
</code></pre>
      
    <h5>‚Ä¢ <code>datetime</code>: Tractament de dates (i hores) en python.</h5>
        <pre><code>from datetime import datetime, date

avui = date.today()
ara = datetime.now()

print(avui)  # data actual
print(avui.year)
print(avui.month)

print(ara)   # data i hora actual           </code></pre> 
    
        <h4>Instal¬∑laci√≥ de Paquets Externs</h4>
        <p>Per utilitzar paquets desenvolupats per tercers, els pots instal¬∑lar des del repositori PyPI utilitzant pip:</p>
        <pre><code>pip3 install nom_del_paquet</code></pre>
    
        <h5>Exemple: Instal¬∑lar <code>requests</code> per realitzar sol¬∑licituds HTTP:</h5>
        <pre><code>import requests
    response = requests.get("https://example.com")
    print(response.status_code)</code></pre>

    <h2>Altres biblioteques en Python</h2>

    <h3>Incloses en la biblioteca est√†ndard</h3>
    <ul>
        <li><strong>os:</strong> Per a interactuar amb el sistema operatiu (crear carpetes, llegir fitxers, etc.).</li>
        <li><strong>sys:</strong> Per accedir a informaci√≥ del sistema i dels arguments passats al programa.</li>
        <li><strong>json:</strong> Per llegir i escriure dades en format JSON.</li>
        <li><strong>datetime:</strong> Per gestionar dates i hores.</li>
        <li><strong>math:</strong> Proporciona funcions matem√†tiques avan√ßades com arrels quadrades, trigonometria, etc.</li>
        <li><strong>decimal:</strong> Per a c√†lculs de precisi√≥ elevada, √∫til en contextos financers.</li>
        <li><strong>random:</strong> Per generar nombres aleatoris.</li>
        <li><strong>re:</strong> Per treballar amb expressions regulars (regex).</li>
        <li><strong>collections:</strong> Ofereix estructures de dades avan√ßades com <code>Counter</code>, <code>deque</code>, <code>defaultdict</code>, etc.</li>
        <li><strong>itertools:</strong> Funcions per manipular iteradors de forma eficient.</li>
        <li><strong>sqlite3:</strong> Per gestionar bases de dades SQLite de forma directa en Python.</li>
    </ul>
    <p>Pots veure tots els m√≤duls disponibles amb <code>help()</code> dins de l‚Äôint√®rpret de Python, i despr√©s escriure <code>modules</code>.</p>

    <h3>Biblioteques externes populars</h3>
    <ul>
        <li><strong>NumPy:</strong> Per a c√†lculs num√®rics r√†pids i eficients.</li>
        <li><strong>Pandas:</strong> Per al tractament de dades tabulars (com taules, fulls de c√†lcul, etc.).</li>
        <li><strong>Matplotlib:</strong> Per crear gr√†fics i visualitzacions b√†siques.</li>
        <li><strong>Seaborn:</strong> Basada en Matplotlib, permet crear gr√†fics estad√≠stics atractius i senzills.</li>
        <li><strong>Scikit-learn:</strong> Llibreria per a aprenentatge autom√†tic (machine learning).</li>
        <li><strong>Flask</strong> i <strong>Django:</strong> Frameworks per a desenvolupament web amb Python.</li>
        <li><strong>Requests:</strong> Per fer peticions HTTP com GET, POST, etc.</li>
        <li><strong>BeautifulSoup:</strong> Per fer <em>web scraping</em> (extracci√≥ d‚Äôinformaci√≥ de p√†gines web).</li>
        <li><strong>TensorFlow</strong> i <strong>PyTorch:</strong> Llibreries potents per a intel¬∑lig√®ncia artificial i <em>deep learning</em>.</li>
        <li><strong>Typer:</strong> Per crear interf√≠cies de l√≠nia de comandes (CLI) de forma r√†pida i elegant.</li>
        <li><strong>OpenCV:</strong> Per a processament d‚Äôimatges i visi√≥ artificial.</li>
        <li><strong>Pillow:</strong> Per a manipulaci√≥ d‚Äôimatges (redimensionar, retallar, etc.).</li>
        <li>...i moltes m√©s.</li>
    </ul>

    <p><strong>Nota:</strong> Les biblioteques externes s‚Äôinstal¬∑len normalment amb <code>pip</code>, per exemple: <code>pip install numpy</code>.</p>

</section>

<section id="main">
    <h1>√ös de <code>__main__</code> en Python</h1>

    <p>En Python, la construcci√≥ <code>if __name__ == "__main__":</code> √©s una forma est√†ndard d'assegurar-se que un bloc de codi nom√©s s'executi quan el fitxer s'executa directament, i no quan s'importa com un m√≤dul en un altre fitxer.</p>

    <h2>Desglossament de la seua funci√≥:</h2>
    <ul>
        <li><strong><code>__name__</code>:</strong> √âs una variable especial a Python que es defineix autom√†ticament.
            <ul>
                <li>Si el fitxer s'executa directament, <code>__name__</code> pren el valor de <code>"__main__"</code>.</li>
                <li>Si el fitxer s'importa com a m√≤dul, <code>__name__</code> pren el nom del fitxer (sense l'extensi√≥ .py).</li>
            </ul>
        </li>
        <li><strong><code>if __name__ == "__main__":</code></strong>
            <ul>
                <li>Aquest condicional avalua si el script est√† sent executat directament (no importat).</li>
                <li>Si la condici√≥ √©s verdadera, el codi dins del bloc s'executar√†.</li>
            </ul>
        </li>
    </ul>

    <h2>Per qu√® √©s √∫til?</h2>
    <p>Aix√≤ √©s especialment √∫til per:</p>
    <ul>
        <li>Separar el codi que ha d'executar-se nom√©s quan el fitxer √©s el "principal" del programa (com proves, l√≤gica principal o execuci√≥ directa).</li>
        <li>Permetre que el fitxer siga importat com a m√≤dul sense executar autom√†ticament el seu codi principal.</li>
    </ul>

    <h2>Exemple pr√†ctic:</h2>
    <pre><code># Arxiu: mi_script.py
def funcion_util():
    print("Aquesta funci√≥ pot ser utilitzada en altres m√≤duls.")

if __name__ == "__main__":
    print("Aquest script s'est√† executant directament.")
    funcion_util()</code></pre>

    <h3>Si executem mi_script.py directament:</h3>
    <pre><code>$ python mi_script.py
Aquest script s'est√† executant directament.
Aquesta funci√≥ pot ser utilitzada en altres m√≤duls.</code></pre>

    <h3>Si importem mi_script des d'un altre fitxer:</h3>
    <pre><code>import mi_script
mi_script.funcion_util()
Aquesta funci√≥ pot ser utilitzada en altres m√≤duls.</code></pre>

    <p>El bloc dins de <code>if __name__ == "__main__":</code> no s'executar√† perqu√® el fitxer no s'est√† executant directament.</p>

</section>

<section id="ascii">
  <h1>ASCII / UNICODE</h1>
      <p><strong>ASCII</strong> (American Standard Code for Information Interchange) √©s un codi que assigna n√∫meros
         als car√†cters perqu√® els ordinadors els puguen entendre.</p>

    <ul>
        <li>Cada car√†cter (lletres, n√∫meros, signes de puntuaci√≥) t√© un valor num√®ric entre 0 i 127.</li>
         * Exemple: '0' = 48 , 'A' = 65, 'B' = 66, 'a' = 97 
        <li>√âs molt simple i nom√©s cobreix l‚Äôalfabet angl√®s i alguns s√≠mbols.</li>
        <li>Els accents, la √±, o car√†cters especials no estan inclosos en ASCII original, per aix√≤ hi ha codificacions ASCII est√©s, i m√©s modernes com UTF-8.</li>
    </ul>
    <h3>ASCII Est√©s (extended ASCII)</h3>
    <p>L‚ÄôASCII est√®s √©s una ampliaci√≥ no oficial de l‚ÄôASCII original. <br>
    L‚ÄôASCII original nom√©s usa 7 bits ‚Üí valors del 0 al 127 <br>
    L‚ÄôASCII est√®s usa 8 bits ‚Üí valors del 0 al 255 <br>
    Aix√≤ permet afegir 128 car√†cters m√©s (del 128 al 255), com: lletres amb accents (√°, √©, √±), s√≠mbols (√ß, ¬£, ¬©) ,car√†cters gr√†fics</p>
    Exemple i breu hist√≤ria de  <a href="https://elcodigoascii.com.ar/">Taula ASCII</a>
    <h3>UNICODE</h3>
    <p><strong>Unicode</strong> √©s un est√†ndard que assigna un n√∫mero √∫nic a cada car√†cter de tots els idiomes i s√≠mbols del m√≥n,
         perqu√® els ordinadors puguen representar qualsevol text de manera consistent.</p>
    <ul>
        <li>Cobreix milers de car√†cters: lletres amb accents, emojis, s√≠mbols matem√†tics, car√†cters xinesos, etc.</li>
        <li>Cada car√†cter t√© un codi √∫nic, anomenat code point, per exemple:</li>
        'A' = U+0041,  '√©' = U+00E9,  'üòä' = U+1F60A
        <li>Funciona amb diferents codificacions com UTF-8 o UTF-16, que s√≥n com ‚Äúformats‚Äù per guardar els car√†cters en bytes.</li>
    </ul>
    <p>En resum: Unicode √©s l‚Äôevoluci√≥ de l‚ÄôASCII, permetent que qualsevol text del m√≥n siga representat sense problemes.</p>

    <h3>Caracters compostos</h3>
    <pre><code>En python.. 
a = "√©"
b = "eÃÅ"  # e + ‚óåÃÅ (e + ACUTE COMBINING)
print(a == b)  # ‚ùå False
</code></pre>
    <p>Tot i que visualment semblen iguals (‚Äú√©‚Äù), internament s√≥n diferents:</p>
    <ul>
        <li>a = "√©" ‚Üí U+00E9 ‚Üí LATIN SMALL LETTER E WITH ACUTE (un sol car√†cter)</li>
        <li>b = "eÃÅ" ‚Üí U+0065 + U+0301 ‚Üí LATIN SMALL LETTER E + COMBINING ACUTE ACCENT (dos car√†cters)</li>
    </ul>
    <p>Python compara els codis Unicode, no com es veuen en pantalla. Per aix√≤ a != b.</p>
    <pre><code>Com comprovar-ho 
for c in a:
    print(hex(ord(c)))

for c in b:
    print(hex(ord(c)))      </code></pre>
    <pre><code> Eixida 
# a
0xe9

# b
0x65
0x301      </code></pre>
    <p>Aix√≤ mostra clarament que un √©s un √∫nic car√†cter i l‚Äôaltre s√≥n dos.</p>
    <pre><code> Soluci√≥: Normalitzaci√≥ Unicode 
import unicodedata

a = "√©"
b = "eÃÅ"

# Normalitzar a la forma composta NFC
a_norm = unicodedata.normalize("NFC", a)
b_norm = unicodedata.normalize("NFC", b)

print(a_norm == b_norm)  # ‚úÖ True       </code></pre>

    <ul> üìå Tipus de normalitzaci√≥:
        <li>NFC ‚Üí forma composta (uneix car√†cters i accents en un de sol)</li>
        <li>NFD ‚Üí forma descomposta (separa car√†cters i accents)</li>
        <li>NFKC, NFKD ‚Üí versions ‚Äúcompatibles‚Äù que tamb√© transformen ligadures i s√≠mbols</li>
    </ul>
    <ul> ‚úÖ Resum
        <li>"√©" i "eÃÅ" es veuen igual, per√≤ s√≥n diferents internament.</li>
        <li>Python compara codis Unicode, no aparen√ßa.</li>
        <li>La soluci√≥ √©s normalitzar abans de comparar strings amb accents o car√†cters especials.</li>
    </ul>
   <p>En el exemple <code>‚óåÃÅ (e + ACUTE COMBINING)</code> √©s un car√†cter "marca combinant". <br>
   Les <strong>marques combinants</strong> s√≥n car√†cters Unicode dissenyats per modificar visualment un car√†cter base anterior, com accents o punts, sense ocupar espai propi
    i tenen una marca amb categoria ‚Äúcombining mark‚Äù (Mn, Mc) .   </p>
   <ul>
    <li>Mn (Non-Spacing Mark): Marques que no ocupen espai horitzontal.</li>
    <li>Mc (Spacing Combining Mark): Marques que ocupen espai horitzontal per√≤ segueixen combinant-se (Menys habituals en alfabet llat√≠)</li>
    <li>Me ‚Üí Enclosing Mark: Es dibuixa al voltant del car√†cter base</li>
   </ul>
   
   
</section>



<section id="exercicis">
  <h1>Exercicis</h1>
  <h3>Els exercicis i tests corresponents a esta unitat es troben en Aules</h3>
</section>


</main>

<script>

  // Per poder copiar codi en el porta-retalls. S'ha de posar un bot√≥ en cada <pre>
      //  <div class="pre-container">
      //    <button class="copy-button">Copia Codi !</button>
  document.addEventListener('DOMContentLoaded', function () {
    const buttons = document.querySelectorAll('.copy-button');

    buttons.forEach(button => {
      button.addEventListener('click', function () {
        const code = this.nextElementSibling.innerText;
        navigator.clipboard.writeText(code).then(() => {
          this.innerText = ' ‚úî Copiat!';
          setTimeout(() => this.innerText = 'Copia Codi !', 3000);
        });
      });
    });
  });

</script>


</body>
</html>
